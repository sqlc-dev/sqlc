// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"
	"net/netip"
	"time"
)

const analyzeArrayElements = `-- name: AnalyzeArrayElements :many
SELECT 
	product_id,
	arrayJoin(categories) AS category,
	COUNT(*) OVER (PARTITION BY category) as category_count
FROM sqlc_example.products
WHERE product_id = ?
GROUP BY product_id, category;
`

type AnalyzeArrayElementsRow struct {
	ProductID     uint32
	Category      string
	CategoryCount uint64
}

func (q *Queries) AnalyzeArrayElements(ctx context.Context, productID uint32) ([]AnalyzeArrayElementsRow, error) {
	rows, err := q.db.Query(ctx, analyzeArrayElements, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnalyzeArrayElementsRow
	for rows.Next() {
		var i AnalyzeArrayElementsRow
		if err := rows.Scan(&i.ProductID, &i.Category, &i.CategoryCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const extractMetadataFromJSON = `-- name: ExtractMetadataFromJSON :many
SELECT 
	id,
	arrayJoin(JSONExtract(json_value, 'Array(String)')) as metadata_value
FROM sqlc_example.events;
`

type ExtractMetadataFromJSONRow struct {
	ID            uint32
	MetadataValue string
}

func (q *Queries) ExtractMetadataFromJSON(ctx context.Context) ([]ExtractMetadataFromJSONRow, error) {
	rows, err := q.db.Query(ctx, extractMetadataFromJSON)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtractMetadataFromJSONRow
	for rows.Next() {
		var i ExtractMetadataFromJSONRow
		if err := rows.Scan(&i.ID, &i.MetadataValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterByIPRange = `-- name: FilterByIPRange :many
SELECT id, source_ip, dest_ip, timestamp, bytes_sent
FROM sqlc_example.network_logs
WHERE source_ip >= $1 AND source_ip <= $2
ORDER BY timestamp DESC;

`

type FilterByIPRangeParams struct {
	MinIp netip.Addr
	MaxIp netip.Addr
}

type FilterByIPRangeRow struct {
	ID        uint32
	SourceIp  netip.Addr
	DestIp    netip.Addr
	Timestamp time.Time
	BytesSent uint64
}

// Complex CTE with UNION query (tests UNION inside unnamed subqueries)
func (q *Queries) FilterByIPRange(ctx context.Context, arg FilterByIPRangeParams) ([]FilterByIPRangeRow, error) {
	rows, err := q.db.Query(ctx, filterByIPRange, arg.MinIp, arg.MaxIp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FilterByIPRangeRow
	for rows.Next() {
		var i FilterByIPRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceIp,
			&i.DestIp,
			&i.Timestamp,
			&i.BytesSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const filterUsersByIDAndStatus = `-- name: FilterUsersByIDAndStatus :many
SELECT id, name, email, status, created_at
FROM sqlc_example.users
WHERE id IN ($1)
AND status IN ('active', 'pending')
ORDER BY created_at DESC;

`

// ORDER BY with WITH FILL for time series
func (q *Queries) FilterUsersByIDAndStatus(ctx context.Context, userIds []uint32) ([]SqlcExampleUser, error) {
	rows, err := q.db.Query(ctx, filterUsersByIDAndStatus, userIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SqlcExampleUser
	for rows.Next() {
		var i SqlcExampleUser
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCastedValues = `-- name: GetCastedValues :many
SELECT 
	id::String as id_text,
	amount::Float32 as amount_float,
	created_at::Date as date_only,
	status::String as status_text
FROM sqlc_example.events
WHERE created_at::Date >= $1;

`

type GetCastedValuesRow struct {
	IDText      string
	AmountFloat float32
	DateOnly    time.Time
	StatusText  string
}

// ARRAY JOIN examples
func (q *Queries) GetCastedValues(ctx context.Context, dateFilter time.Time) ([]GetCastedValuesRow, error) {
	rows, err := q.db.Query(ctx, getCastedValues, dateFilter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCastedValuesRow
	for rows.Next() {
		var i GetCastedValuesRow
		if err := rows.Scan(
			&i.IDText,
			&i.AmountFloat,
			&i.DateOnly,
			&i.StatusText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentAnalytics = `-- name: GetCommentAnalytics :many
SELECT 
	p.id as post_id,
	p.title,
	COUNT(*) as total_comments,
	uniqExact(c.user_id) as unique_commenters,
	countIf(c.created_at >= toDate(now()) - 7) as comments_last_week,
	argMin(c.created_at, c.id) as first_comment_time,
	argMax(c.created_at, c.id) as last_comment_time
FROM sqlc_example.posts p
LEFT JOIN sqlc_example.comments c ON p.id = c.post_id
WHERE p.user_id = $1
GROUP BY p.id, p.title
ORDER BY total_comments DESC;

`

type GetCommentAnalyticsRow struct {
	PostID           uint32
	Title            string
	TotalComments    uint64
	UniqueCommenters uint64
	CommentsLastWeek uint64
	FirstCommentTime time.Time
	LastCommentTime  time.Time
}

// Statistical aggregate functions
func (q *Queries) GetCommentAnalytics(ctx context.Context, userID uint32) ([]GetCommentAnalyticsRow, error) {
	rows, err := q.db.Query(ctx, getCommentAnalytics, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentAnalyticsRow
	for rows.Next() {
		var i GetCommentAnalyticsRow
		if err := rows.Scan(
			&i.PostID,
			&i.Title,
			&i.TotalComments,
			&i.UniqueCommenters,
			&i.CommentsLastWeek,
			&i.FirstCommentTime,
			&i.LastCommentTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsForPost = `-- name: GetCommentsForPost :many
SELECT id, post_id, user_id, content, created_at
FROM sqlc_example.comments
WHERE post_id = $1
ORDER BY created_at ASC;
`

func (q *Queries) GetCommentsForPost(ctx context.Context, postID uint32) ([]SqlcExampleComment, error) {
	rows, err := q.db.Query(ctx, getCommentsForPost, postID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SqlcExampleComment
	for rows.Next() {
		var i SqlcExampleComment
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.UserID,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfigData = `-- name: GetConfigData :one
SELECT id, settings, metrics, tags, created_at
FROM sqlc_example.config_data
WHERE id = ?;
`

func (q *Queries) GetConfigData(ctx context.Context, id uint32) (SqlcExampleConfigDatum, error) {
	row := q.db.QueryRow(ctx, getConfigData, id)
	var i SqlcExampleConfigDatum
	err := row.Scan(
		&i.ID,
		&i.Settings,
		&i.Metrics,
		&i.Tags,
		&i.CreatedAt,
	)
	return i, err
}

const getConfigSettings = `-- name: GetConfigSettings :many
SELECT id, settings, created_at
FROM sqlc_example.config_data
WHERE id > $1
ORDER BY id;
`

type GetConfigSettingsRow struct {
	ID        uint32
	Settings  map[string]string
	CreatedAt time.Time
}

func (q *Queries) GetConfigSettings(ctx context.Context, minID uint32) ([]GetConfigSettingsRow, error) {
	rows, err := q.db.Query(ctx, getConfigSettings, minID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetConfigSettingsRow
	for rows.Next() {
		var i GetConfigSettingsRow
		if err := rows.Scan(&i.ID, &i.Settings, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIPv6Connections = `-- name: GetIPv6Connections :many
SELECT id, source_ipv6, dest_ipv6, timestamp, bytes_sent
FROM sqlc_example.network_logs
WHERE source_ipv6 IS NOT NULL AND dest_ipv6 IS NOT NULL
ORDER BY timestamp DESC;
`

type GetIPv6ConnectionsRow struct {
	ID         uint32
	SourceIpv6 *netip.Addr
	DestIpv6   *netip.Addr
	Timestamp  time.Time
	BytesSent  uint64
}

func (q *Queries) GetIPv6Connections(ctx context.Context) ([]GetIPv6ConnectionsRow, error) {
	rows, err := q.db.Query(ctx, getIPv6Connections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIPv6ConnectionsRow
	for rows.Next() {
		var i GetIPv6ConnectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceIpv6,
			&i.DestIpv6,
			&i.Timestamp,
			&i.BytesSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsStatistics = `-- name: GetMetricsStatistics :many
SELECT 
	category,
	COUNT(*) as count,
	varSamp(value) as variance_sample,
	varPop(value) as variance_population,
	stddevSamp(value) as stddev_sample,
	stddevPop(value) as stddev_population,
	corr(value_x, value_y) as correlation
FROM sqlc_example.metrics
WHERE timestamp >= $1 AND timestamp <= $2
GROUP BY category
ORDER BY count DESC;

`

type GetMetricsStatisticsParams struct {
	StartTime time.Time
	EndTime   time.Time
}

type GetMetricsStatisticsRow struct {
	Category           string
	Count              uint64
	VarianceSample     float64
	VariancePopulation float64
	StddevSample       float64
	StddevPopulation   float64
	Correlation        float64
}

// Conditional aggregate variants
func (q *Queries) GetMetricsStatistics(ctx context.Context, arg GetMetricsStatisticsParams) ([]GetMetricsStatisticsRow, error) {
	rows, err := q.db.Query(ctx, getMetricsStatistics, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMetricsStatisticsRow
	for rows.Next() {
		var i GetMetricsStatisticsRow
		if err := rows.Scan(
			&i.Category,
			&i.Count,
			&i.VarianceSample,
			&i.VariancePopulation,
			&i.StddevSample,
			&i.StddevPopulation,
			&i.Correlation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNetworkLogBySourceIP = `-- name: GetNetworkLogBySourceIP :one
SELECT id, source_ip, dest_ip, source_ipv6, dest_ipv6, timestamp, bytes_sent
FROM sqlc_example.network_logs
WHERE source_ip = $1;
`

func (q *Queries) GetNetworkLogBySourceIP(ctx context.Context, sourceIp netip.Addr) (SqlcExampleNetworkLog, error) {
	row := q.db.QueryRow(ctx, getNetworkLogBySourceIP, sourceIp)
	var i SqlcExampleNetworkLog
	err := row.Scan(
		&i.ID,
		&i.SourceIp,
		&i.DestIp,
		&i.SourceIpv6,
		&i.DestIpv6,
		&i.Timestamp,
		&i.BytesSent,
	)
	return i, err
}

const getNetworkLogsByDestIP = `-- name: GetNetworkLogsByDestIP :many
SELECT id, source_ip, dest_ip, timestamp, bytes_sent
FROM sqlc_example.network_logs
WHERE dest_ip = $1
ORDER BY timestamp DESC;
`

type GetNetworkLogsByDestIPRow struct {
	ID        uint32
	SourceIp  netip.Addr
	DestIp    netip.Addr
	Timestamp time.Time
	BytesSent uint64
}

func (q *Queries) GetNetworkLogsByDestIP(ctx context.Context, destIp netip.Addr) ([]GetNetworkLogsByDestIPRow, error) {
	rows, err := q.db.Query(ctx, getNetworkLogsByDestIP, destIp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNetworkLogsByDestIPRow
	for rows.Next() {
		var i GetNetworkLogsByDestIPRow
		if err := rows.Scan(
			&i.ID,
			&i.SourceIp,
			&i.DestIp,
			&i.Timestamp,
			&i.BytesSent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderMetrics = `-- name: GetOrderMetrics :many
SELECT 
	status,
	COUNT(*) as total_orders,
	minIf(amount, amount > 0) as min_positive_amount,
	maxIf(amount, amount > 0) as max_positive_amount,
	sumIf(amount, status = 'completed') as completed_revenue,
	avgIf(rating, rating IS NOT NULL) as avg_valid_rating
FROM sqlc_example.order_metrics
WHERE created_at >= $1
GROUP BY status
ORDER BY total_orders DESC;

`

type GetOrderMetricsRow struct {
	Status            string
	TotalOrders       uint64
	MinPositiveAmount float64
	MaxPositiveAmount float64
	CompletedRevenue  float64
	AvgValidRating    float64
}

// IN operator with multiple conditions
func (q *Queries) GetOrderMetrics(ctx context.Context, startDate time.Time) ([]GetOrderMetricsRow, error) {
	rows, err := q.db.Query(ctx, getOrderMetrics, startDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrderMetricsRow
	for rows.Next() {
		var i GetOrderMetricsRow
		if err := rows.Scan(
			&i.Status,
			&i.TotalOrders,
			&i.MinPositiveAmount,
			&i.MaxPositiveAmount,
			&i.CompletedRevenue,
			&i.AvgValidRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrdersWithShipments = `-- name: GetOrdersWithShipments :many
SELECT order_id, customer_name, amount, created_at, shipment_id, address, shipped_at
FROM sqlc_example.orders
LEFT JOIN sqlc_example.shipments USING (order_id)
ORDER BY created_at DESC;
`

type GetOrdersWithShipmentsRow struct {
	OrderID      uint32
	CustomerName string
	Amount       float64
	CreatedAt    time.Time
	ShipmentID   *uint32
	Address      *string
	ShippedAt    *time.Time
}

func (q *Queries) GetOrdersWithShipments(ctx context.Context) ([]GetOrdersWithShipmentsRow, error) {
	rows, err := q.db.Query(ctx, getOrdersWithShipments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOrdersWithShipmentsRow
	for rows.Next() {
		var i GetOrdersWithShipmentsRow
		if err := rows.Scan(
			&i.OrderID,
			&i.CustomerName,
			&i.Amount,
			&i.CreatedAt,
			&i.ShipmentID,
			&i.Address,
			&i.ShippedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlatformHistory = `-- name: GetPlatformHistory :many
WITH platform_info AS (
    SELECT platform_id, 
        argMax(platform_name, timestamp) as platform_name,
        argMax(region, timestamp) as region
    FROM (
        SELECT timestamp, platform_id, platform_name, region
        FROM sqlc_example.platform_created_event
        
        UNION ALL
        
        SELECT timestamp, platform_id, new_name as platform_name, region
        FROM sqlc_example.platform_renamed_event
    ) AS platform_events
    GROUP BY platform_id
), usage_summary AS (
    SELECT feature_usage.platform_id, feature_id,
        COUNT(*) AS update_count,
        uniqExact(user_count) AS unique_user_counts,
        SUM(usage_count) AS total_usage
    FROM sqlc_example.feature_usage
    WHERE feature_usage.platform_id = $1
    GROUP BY feature_usage.platform_id, feature_id
    ORDER BY total_usage DESC
)

SELECT 
    u.platform_id,
    u.feature_id,
    u.update_count,
    u.unique_user_counts,
    u.total_usage,
    p.platform_name,
    p.region
FROM usage_summary u
LEFT JOIN platform_info p ON u.platform_id = p.platform_id;

`

type GetPlatformHistoryRow struct {
	PlatformID       uint32
	FeatureID        string
	UpdateCount      uint64
	UniqueUserCounts uint64
	TotalUsage       uint64
	PlatformName     *string
	Region           *string
}

// LEFT JOIN USING clause test
// This ensures that USING clause returns only one column (not duplicated)
// ClickHouse naturally returns a single column for the shared key with USING
// After sqlc expansion, this should generate: order_id, customer_name, amount, created_at, shipment_id, address, shipped_at
// NOT: order_id, customer_name, amount, created_at, order_id, shipment_id, address, shipped_at (with order_id duplicated)
func (q *Queries) GetPlatformHistory(ctx context.Context, platformID uint32) ([]GetPlatformHistoryRow, error) {
	rows, err := q.db.Query(ctx, getPlatformHistory, platformID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPlatformHistoryRow
	for rows.Next() {
		var i GetPlatformHistoryRow
		if err := rows.Scan(
			&i.PlatformID,
			&i.FeatureID,
			&i.UpdateCount,
			&i.UniqueUserCounts,
			&i.TotalUsage,
			&i.PlatformName,
			&i.Region,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByOptionalStatus = `-- name: GetPostsByOptionalStatus :many
SELECT id, user_id, title, status, created_at
FROM sqlc_example.posts
WHERE ($1 IS NULL OR status = $1)
ORDER BY created_at DESC;

`

type GetPostsByOptionalStatusRow struct {
	ID        uint32
	UserID    uint32
	Title     string
	Status    *string
	CreatedAt time.Time
}

// ClickHouse-specific aggregate functions
func (q *Queries) GetPostsByOptionalStatus(ctx context.Context, status *string) ([]GetPostsByOptionalStatusRow, error) {
	rows, err := q.db.Query(ctx, getPostsByOptionalStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsByOptionalStatusRow
	for rows.Next() {
		var i GetPostsByOptionalStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeSeriesWithFill = `-- name: GetTimeSeriesWithFill :many
SELECT date, metric_value
FROM sqlc_example.timeseries
WHERE date >= $1 AND date <= $2
ORDER BY date WITH FILL FROM sqlc.arg('start_date') TO sqlc.arg('end_date');

`

type GetTimeSeriesWithFillParams struct {
	StartDate time.Time
	EndDate   time.Time
}

// Type casting examples
func (q *Queries) GetTimeSeriesWithFill(ctx context.Context, arg GetTimeSeriesWithFillParams) ([]SqlcExampleTimeseries, error) {
	rows, err := q.db.Query(ctx, getTimeSeriesWithFill, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SqlcExampleTimeseries
	for rows.Next() {
		var i SqlcExampleTimeseries
		if err := rows.Scan(&i.Date, &i.MetricValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAnalytics = `-- name: GetUserAnalytics :many
SELECT 
	u.id,
	u.name,
	COUNT(*) as total_posts,
	uniqExact(p.id) as unique_posts,
	countIf(p.created_at >= toDate(now()) - 30) as posts_last_30_days,
	argMax(p.title, p.created_at) as latest_post_title,
	argMaxIf(p.title, p.created_at, p.created_at >= toDate(now()) - 30) as latest_post_in_30_days
FROM sqlc_example.users u
LEFT JOIN sqlc_example.posts p ON u.id = p.user_id
GROUP BY u.id, u.name
HAVING COUNT(*) > 0
ORDER BY total_posts DESC;
`

type GetUserAnalyticsRow struct {
	ID                 uint32
	Name               string
	TotalPosts         uint64
	UniquePosts        uint64
	PostsLast30Days    uint64
	LatestPostTitle    string
	LatestPostIn30Days string
}

func (q *Queries) GetUserAnalytics(ctx context.Context) ([]GetUserAnalyticsRow, error) {
	rows, err := q.db.Query(ctx, getUserAnalytics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAnalyticsRow
	for rows.Next() {
		var i GetUserAnalyticsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.TotalPosts,
			&i.UniquePosts,
			&i.PostsLast30Days,
			&i.LatestPostTitle,
			&i.LatestPostIn30Days,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, name, email, created_at
FROM sqlc_example.users
WHERE email = $1;
`

type GetUserByEmailRow struct {
	ID        uint32
	Name      string
	Email     string
	CreatedAt time.Time
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, name, email, created_at
FROM sqlc_example.users
WHERE id = ?;
`

type GetUserByIDRow struct {
	ID        uint32
	Name      string
	Email     string
	CreatedAt time.Time
}

func (q *Queries) GetUserByID(ctx context.Context, id uint32) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.CreatedAt,
	)
	return i, err
}

const getUserPostsForUser = `-- name: GetUserPostsForUser :many
SELECT p.id, p.user_id, p.title, p.content, p.created_at
FROM sqlc_example.posts p
WHERE p.user_id = $1
ORDER BY p.created_at DESC;
`

type GetUserPostsForUserRow struct {
	ID        uint32
	UserID    uint32
	Title     string
	Content   string
	CreatedAt time.Time
}

func (q *Queries) GetUserPostsForUser(ctx context.Context, userID uint32) ([]GetUserPostsForUserRow, error) {
	rows, err := q.db.Query(ctx, getUserPostsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPostsForUserRow
	for rows.Next() {
		var i GetUserPostsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Content,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWithPosts = `-- name: GetUserWithPosts :many
SELECT u.id, u.name, u.email, u.created_at, p.id as post_id, p.title
FROM sqlc_example.users u
LEFT JOIN sqlc_example.posts p ON u.id = p.user_id
WHERE u.id = $1
ORDER BY p.created_at DESC;

`

type GetUserWithPostsRow struct {
	ID        uint32
	Name      string
	Email     string
	CreatedAt time.Time
	PostID    *uint32
	Title     *string
}

// Named parameter with nullable values using sqlc.narg()
func (q *Queries) GetUserWithPosts(ctx context.Context, userID uint32) ([]GetUserWithPostsRow, error) {
	rows, err := q.db.Query(ctx, getUserWithPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserWithPostsRow
	for rows.Next() {
		var i GetUserWithPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.CreatedAt,
			&i.PostID,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertComment = `-- name: InsertComment :exec
INSERT INTO sqlc_example.comments (id, post_id, user_id, content, created_at)
VALUES (?, ?, ?, ?, ?);
`

type InsertCommentParams struct {
	ID        uint32
	PostID    uint32
	UserID    uint32
	Content   string
	CreatedAt time.Time
}

func (q *Queries) InsertComment(ctx context.Context, arg InsertCommentParams) error {
	err := q.db.Exec(ctx, insertComment,
		arg.ID,
		arg.PostID,
		arg.UserID,
		arg.Content,
		arg.CreatedAt,
	)
	return err
}

const insertConfigData = `-- name: InsertConfigData :exec
INSERT INTO sqlc_example.config_data (id, settings, metrics, tags, created_at)
VALUES (?, ?, ?, ?, ?);

`

type InsertConfigDataParams struct {
	ID        uint32
	Settings  map[string]string
	Metrics   map[string]float64
	Tags      map[string][]string
	CreatedAt time.Time
}

// IP address type examples
func (q *Queries) InsertConfigData(ctx context.Context, arg InsertConfigDataParams) error {
	err := q.db.Exec(ctx, insertConfigData,
		arg.ID,
		arg.Settings,
		arg.Metrics,
		arg.Tags,
		arg.CreatedAt,
	)
	return err
}

const insertNetworkLog = `-- name: InsertNetworkLog :exec
INSERT INTO sqlc_example.network_logs (id, source_ip, dest_ip, source_ipv6, dest_ipv6, timestamp, bytes_sent)
VALUES ($1, $2, $3, $4, $5, $6, $7);
`

type InsertNetworkLogParams struct {
	ID         uint32
	SourceIp   netip.Addr
	DestIp     netip.Addr
	SourceIpv6 *netip.Addr
	DestIpv6   *netip.Addr
	Timestamp  time.Time
	BytesSent  uint64
}

func (q *Queries) InsertNetworkLog(ctx context.Context, arg InsertNetworkLogParams) error {
	err := q.db.Exec(ctx, insertNetworkLog,
		arg.ID,
		arg.SourceIp,
		arg.DestIp,
		arg.SourceIpv6,
		arg.DestIpv6,
		arg.Timestamp,
		arg.BytesSent,
	)
	return err
}

const insertPost = `-- name: InsertPost :exec
INSERT INTO sqlc_example.posts (id, user_id, title, content, created_at)
VALUES ($1, $2, $3, $4, $5);
`

type InsertPostParams struct {
	ID        uint32
	UserID    uint32
	Title     string
	Content   string
	CreatedAt time.Time
}

func (q *Queries) InsertPost(ctx context.Context, arg InsertPostParams) error {
	err := q.db.Exec(ctx, insertPost,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Content,
		arg.CreatedAt,
	)
	return err
}

const insertUser = `-- name: InsertUser :exec
INSERT INTO sqlc_example.users (id, name, email, created_at)
VALUES (?, ?, ?, ?);

`

type InsertUserParams struct {
	ID        uint32
	Name      string
	Email     string
	CreatedAt time.Time
}

// Named parameter examples using sqlc.arg() function
func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) error {
	err := q.db.Exec(ctx, insertUser,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.CreatedAt,
	)
	return err
}

const insertUserNamed = `-- name: InsertUserNamed :exec
INSERT INTO sqlc_example.users (id, name, email, created_at)
VALUES ($1, $2, $3, $4);
`

type InsertUserNamedParams struct {
	ID        uint32
	Name      string
	Email     string
	CreatedAt time.Time
}

func (q *Queries) InsertUserNamed(ctx context.Context, arg InsertUserNamedParams) error {
	err := q.db.Exec(ctx, insertUserNamed,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.CreatedAt,
	)
	return err
}

const listUsers = `-- name: ListUsers :many
SELECT id, name, email, created_at
FROM sqlc_example.users
ORDER BY created_at DESC
LIMIT ?;
`

type ListUsersRow struct {
	ID        uint32
	Name      string
	Email     string
	CreatedAt time.Time
}

func (q *Queries) ListUsers(ctx context.Context, limit int64) ([]ListUsersRow, error) {
	rows, err := q.db.Query(ctx, listUsers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersRow
	for rows.Next() {
		var i ListUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfoldEventProperties = `-- name: UnfoldEventProperties :many
SELECT 
	e.event_id,
	e.event_name,
	e.timestamp,
	prop_key,
	prop_value
FROM sqlc_example.events_with_properties e
ARRAY JOIN e.properties.keys AS prop_key, e.properties.values AS prop_value
WHERE e.timestamp >= $1
ORDER BY e.timestamp DESC;
`

type UnfoldEventPropertiesRow struct {
	EventID   uint32
	EventName string
	Timestamp time.Time
	PropKey   string
	PropValue string
}

func (q *Queries) UnfoldEventProperties(ctx context.Context, startTime time.Time) ([]UnfoldEventPropertiesRow, error) {
	rows, err := q.db.Query(ctx, unfoldEventProperties, startTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnfoldEventPropertiesRow
	for rows.Next() {
		var i UnfoldEventPropertiesRow
		if err := rows.Scan(
			&i.EventID,
			&i.EventName,
			&i.Timestamp,
			&i.PropKey,
			&i.PropValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfoldNestedData = `-- name: UnfoldNestedData :many
SELECT 
	record_id,
	nested_value
FROM sqlc_example.nested_table
ARRAY JOIN nested_array AS nested_value
WHERE record_id IN ($1);
`

type UnfoldNestedDataRow struct {
	RecordID    uint32
	NestedValue string
}

func (q *Queries) UnfoldNestedData(ctx context.Context, recordIds []uint32) ([]UnfoldNestedDataRow, error) {
	rows, err := q.db.Query(ctx, unfoldNestedData, recordIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnfoldNestedDataRow
	for rows.Next() {
		var i UnfoldNestedDataRow
		if err := rows.Scan(&i.RecordID, &i.NestedValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unfoldUserTags = `-- name: UnfoldUserTags :many
SELECT 
	u.id as user_id,
	u.name as user_name,
	tag
FROM sqlc_example.users_with_tags u
ARRAY JOIN u.tags AS tag
WHERE u.id = $1
ORDER BY tag;
`

type UnfoldUserTagsRow struct {
	UserID   uint32
	UserName string
	Tag      string
}

func (q *Queries) UnfoldUserTags(ctx context.Context, userID uint32) ([]UnfoldUserTagsRow, error) {
	rows, err := q.db.Query(ctx, unfoldUserTags, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UnfoldUserTagsRow
	for rows.Next() {
		var i UnfoldUserTagsRow
		if err := rows.Scan(&i.UserID, &i.UserName, &i.Tag); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
