# ClickHouse Example

This example demonstrates using sqlc with ClickHouse for type-safe SQL query compilation and code generation.

## Driver Support

sqlc supports two modes for ClickHouse:

1. **Native Driver** (`sql_package: "clickhouse/v2"`) - Uses the official ClickHouse Go driver with native protocol
2. **Database/SQL** (default) - Uses the standard library `database/sql` package

This example uses the **native driver** for better performance and type support. See [USAGE.md](./USAGE.md) for detailed documentation on both modes.

## Quick Start

First, ensure you have sqlc installed:

```bash
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest
```

Then, from this directory, run:

```bash
sqlc generate
```

This will generate Go code in the `gen/` directory based on the schema and queries.

## Files

- `schema.sql` - Table definitions for the example
- `queries.sql` - Named queries that sqlc will generate code for
- `sqlc.yaml` - Configuration file for sqlc
- `gen/` - Generated Go code (auto-generated by sqlc)

## Schema

The example schema includes:

- `users` table - User information
- `posts` table - Posts created by users  
- `comments` table - Comments on posts

## Queries

The example queries include:

**Positional Parameters:**
- `GetUserByID` - Fetch a single user by ID
- `ListUsers` - List users with limit
- `InsertUser` - Insert a new user

**Named Parameters (@name syntax):**
- `GetUserByIDNamed` - Fetch user using named parameter
- `ListUsersByStatusNamed` - List users with multiple named parameters
- `GetUserPostsForUser` - Get posts by user ID

**Named Parameters (sqlc.arg() syntax):**
- `GetUserByEmail` - Fetch user by email
- `InsertUserNamed` - Insert with named parameters
- `GetUserWithPosts` - Get user with all their posts using JOIN

**Advanced Features:**
- `InsertPost` - Insert post
- `GetCommentsForPost` - Get comments with ordering
- `GetPostsByOptionalStatus` - Nullable parameter handling with `sqlc.narg()`

All queries demonstrate different parameter syntaxes and SQL features supported by ClickHouse in sqlc.

## Parameter Syntax Support

This example shows all three ways to use parameters with ClickHouse in sqlc:

### 1. Positional Parameters (?)
```sql
SELECT * FROM users WHERE id = ?;
```
Generated: `func (q *Queries) GetUserByID(ctx context.Context, dollar_1 interface{}) ...`

### 2. Named Parameters (@name)
```sql
SELECT * FROM users WHERE id = @user_id AND status = @status;
```
Generated: `func (q *Queries) GetUserByIDNamed(ctx context.Context, arg GetUserByIDNamedParams) ...`

With struct:
```go
type GetUserByIDNamedParams struct {
    UserID int32
    Status string
}
```

### 3. Function-Style Named Parameters
```sql
SELECT * FROM users WHERE email = sqlc.arg('email');
SELECT * FROM users WHERE (sqlc.narg('status') IS NULL OR status = sqlc.narg('status'));
SELECT * FROM users WHERE id IN sqlc.slice('ids');
```

**Recommendation:** Use named parameters (`@name` or `sqlc.arg()`) for better code readability and maintenance.

## ClickHouse-Specific Features

This example demonstrates several ClickHouse-specific SQL features:

- **Table Engines**: Uses MergeTree family of table engines
- **ORDER BY**: Defines sort order for tables
- **Partitioning**: Tables are partitioned by primary key
- **Comments**: SQL-style (`--`) and C-style (`/* */`) comments
- **Named Parameters**: All three parameter syntaxes shown above

## Type Resolution

### Table Columns

sqlc now properly resolves ClickHouse table column types to Go types:

- `UInt32` → `uint32` (nullable: `sql.NullInt64`)
- `String` → `string` (nullable: `sql.NullString`)
- `DateTime` → `time.Time` (nullable: `sql.NullTime`)
- Other types are mapped following Go's `database/sql` conventions

Generated table models include proper type information in struct fields.

### Query Columns

Query result columns are generated as `Column1`, `Column2`, etc. with `interface{}` types. This is a known limitation - proper column type resolution for SELECT queries requires either:

1. Database-backed analysis with a ClickHouse connection
2. Complex semantic analysis of SELECT expressions

To enable query column resolution in the future, you can:

1. Run ClickHouse locally
2. Configure the analyzer in your `sqlc.yaml`
3. sqlc will then use `DESCRIBE` queries to resolve result column types

## Notes

- ClickHouse uses backticks for quoting identifiers
- ClickHouse supports `UInt32` and other specialized numeric types
- The `DateTime` type is used for timestamp columns
- MergeTree tables require an `ORDER BY` clause
- Columns are nullable by default - use database constraints if needed
