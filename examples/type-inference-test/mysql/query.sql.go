// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package mysql

import (
	"context"
	"database/sql"
)

const listTest = `-- name: ListTest :many
SELECT 
    (a1 / 1024) a1_float, (a2 / 1024) a2_float, a3
FROM test
`

type ListTestRow struct {
	A1Float string         `json:"a1_float"`
	A2Float sql.NullString `json:"a2_float"`
	A3      float64        `json:"a3"`
}

func (q *Queries) ListTest(ctx context.Context) ([]ListTestRow, error) {
	rows, err := q.db.QueryContext(ctx, listTest)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTestRow
	for rows.Next() {
		var i ListTestRow
		if err := rows.Scan(&i.A1Float, &i.A2Float, &i.A3); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTest2 = `-- name: ListTest2 :many
SELECT 
    COALESCE(CAST(a1 / 1024 AS FLOAT), 0) a1_float, COALESCE(CAST(a2 / 1024 AS FLOAT), 0) a2_float, a3
FROM test
`

type ListTest2Row struct {
	A1Float float64 `json:"a1_float"`
	A2Float float64 `json:"a2_float"`
	A3      float64 `json:"a3"`
}

func (q *Queries) ListTest2(ctx context.Context) ([]ListTest2Row, error) {
	rows, err := q.db.QueryContext(ctx, listTest2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTest2Row
	for rows.Next() {
		var i ListTest2Row
		if err := rows.Scan(&i.A1Float, &i.A2Float, &i.A3); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTest3 = `-- name: ListTest3 :many
SELECT 
    CAST(a1 / 1024 AS FLOAT) a1_float, CAST(a2 / 1024 AS FLOAT) a2_float, a3
FROM test
`

type ListTest3Row struct {
	A1Float float64 `json:"a1_float"`
	A2Float float64 `json:"a2_float"`
	A3      float64 `json:"a3"`
}

func (q *Queries) ListTest3(ctx context.Context) ([]ListTest3Row, error) {
	rows, err := q.db.QueryContext(ctx, listTest3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTest3Row
	for rows.Next() {
		var i ListTest3Row
		if err := rows.Scan(&i.A1Float, &i.A2Float, &i.A3); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTest4 = `-- name: ListTest4 :many
SELECT 
    (a1 + a2) as sum_result,
    (a1 * a2) as mult_result,
    (a1 - a2) as sub_result,
    (a1 % 10) as mod_result
FROM test
`

type ListTest4Row struct {
	SumResult  sql.NullInt32 `json:"sum_result"`
	MultResult sql.NullInt32 `json:"mult_result"`
	SubResult  sql.NullInt32 `json:"sub_result"`
	ModResult  int32         `json:"mod_result"`
}

func (q *Queries) ListTest4(ctx context.Context) ([]ListTest4Row, error) {
	rows, err := q.db.QueryContext(ctx, listTest4)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTest4Row
	for rows.Next() {
		var i ListTest4Row
		if err := rows.Scan(
			&i.SumResult,
			&i.MultResult,
			&i.SubResult,
			&i.ModResult,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTest5 = `-- name: ListTest5 :many
SELECT 
    COALESCE(a1 / 1024, 0) as with_inference,
    COALESCE(a2 / 1024, 0) as nullable_inference
FROM test
`

type ListTest5Row struct {
	WithInference     string `json:"with_inference"`
	NullableInference string `json:"nullable_inference"`
}

func (q *Queries) ListTest5(ctx context.Context) ([]ListTest5Row, error) {
	rows, err := q.db.QueryContext(ctx, listTest5)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTest5Row
	for rows.Next() {
		var i ListTest5Row
		if err := rows.Scan(&i.WithInference, &i.NullableInference); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
