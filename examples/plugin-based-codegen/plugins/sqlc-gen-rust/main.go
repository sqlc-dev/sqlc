// sqlc-gen-rust demonstrates a custom code generation plugin.
//
// This plugin generates Rust code from SQL queries. It shows how external
// repositories can implement language support without modifying sqlc core.
//
// Build: go build -o sqlc-gen-rust .
package main

import (
	"fmt"
	"strings"

	"github.com/sqlc-dev/sqlc/pkg/plugin"
)

func main() {
	plugin.Run(generate)
}

func generate(req *plugin.GenerateRequest) (*plugin.GenerateResponse, error) {
	var sb strings.Builder

	// Header
	sb.WriteString("// Code generated by sqlc-gen-rust. DO NOT EDIT.\n")
	sb.WriteString("// Engine: " + req.Settings.Engine + "\n\n")

	sb.WriteString("use sqlx::{FromRow, SqlitePool};\n")
	sb.WriteString("use anyhow::Result;\n\n")

	// Generate structs from catalog
	if req.Catalog != nil {
		for _, schema := range req.Catalog.Schemas {
			for _, table := range schema.Tables {
				sb.WriteString("#[derive(Debug, FromRow)]\n")
				sb.WriteString(fmt.Sprintf("pub struct %s {\n", pascalCase(table.Rel.Name)))
				for _, col := range table.Columns {
					rustType := mapToRustType(col.Type.Name, col.NotNull)
					sb.WriteString(fmt.Sprintf("    pub %s: %s,\n", snakeCase(col.Name), rustType))
				}
				sb.WriteString("}\n\n")
			}
		}
	}

	// Generate query functions
	for _, q := range req.Queries {
		sb.WriteString(fmt.Sprintf("/// %s\n", q.Name))

		// Function signature
		sb.WriteString(fmt.Sprintf("pub async fn %s(\n", snakeCase(q.Name)))
		sb.WriteString("    pool: &SqlitePool,\n")

		// Parameters
		for _, p := range q.Params {
			rustType := mapToRustType(p.Column.Type.Name, true)
			sb.WriteString(fmt.Sprintf("    %s: %s,\n", snakeCase(p.Column.Name), rustType))
		}

		// Return type
		sb.WriteString(")")
		switch q.Cmd {
		case ":one":
			if len(q.Columns) > 0 {
				sb.WriteString(fmt.Sprintf(" -> Result<Option<%s>>", inferRustReturnType(q)))
			} else {
				sb.WriteString(" -> Result<()>")
			}
		case ":many":
			if len(q.Columns) > 0 {
				sb.WriteString(fmt.Sprintf(" -> Result<Vec<%s>>", inferRustReturnType(q)))
			} else {
				sb.WriteString(" -> Result<()>")
			}
		case ":exec":
			sb.WriteString(" -> Result<()>")
		default:
			sb.WriteString(" -> Result<()>")
		}

		sb.WriteString(" {\n")

		// SQL query
		escapedSQL := strings.ReplaceAll(q.Text, "\n", " ")
		escapedSQL = strings.ReplaceAll(escapedSQL, `"`, `\"`)
		sb.WriteString(fmt.Sprintf("    const QUERY: &str = \"%s\";\n", escapedSQL))

		// Query execution
		switch q.Cmd {
		case ":one":
			sb.WriteString("    let row = sqlx::query_as(QUERY)\n")
			for _, p := range q.Params {
				sb.WriteString(fmt.Sprintf("        .bind(%s)\n", snakeCase(p.Column.Name)))
			}
			sb.WriteString("        .fetch_optional(pool)\n")
			sb.WriteString("        .await?;\n")
			sb.WriteString("    Ok(row)\n")
		case ":many":
			sb.WriteString("    let rows = sqlx::query_as(QUERY)\n")
			for _, p := range q.Params {
				sb.WriteString(fmt.Sprintf("        .bind(%s)\n", snakeCase(p.Column.Name)))
			}
			sb.WriteString("        .fetch_all(pool)\n")
			sb.WriteString("        .await?;\n")
			sb.WriteString("    Ok(rows)\n")
		case ":exec":
			sb.WriteString("    sqlx::query(QUERY)\n")
			for _, p := range q.Params {
				sb.WriteString(fmt.Sprintf("        .bind(%s)\n", snakeCase(p.Column.Name)))
			}
			sb.WriteString("        .execute(pool)\n")
			sb.WriteString("        .await?;\n")
			sb.WriteString("    Ok(())\n")
		default:
			sb.WriteString("    todo!()\n")
		}

		sb.WriteString("}\n\n")
	}

	return &plugin.GenerateResponse{
		Files: []*plugin.File{
			{
				Name:     "queries.rs",
				Contents: []byte(sb.String()),
			},
		},
	}, nil
}

func pascalCase(s string) string {
	if s == "" {
		return s
	}
	words := strings.Split(s, "_")
	for i, w := range words {
		if len(w) > 0 {
			words[i] = strings.ToUpper(w[:1]) + strings.ToLower(w[1:])
		}
	}
	return strings.Join(words, "")
}

func snakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func mapToRustType(sqlType string, notNull bool) string {
	var rustType string
	switch strings.ToLower(sqlType) {
	case "int", "integer", "int4":
		rustType = "i32"
	case "int8", "bigint":
		rustType = "i64"
	case "smallint", "int2":
		rustType = "i16"
	case "text", "varchar", "char", "string":
		rustType = "String"
	case "bool", "boolean":
		rustType = "bool"
	case "float", "real":
		rustType = "f32"
	case "double", "numeric", "decimal":
		rustType = "f64"
	case "blob", "bytea":
		rustType = "Vec<u8>"
	default:
		rustType = "String"
	}
	if !notNull {
		rustType = fmt.Sprintf("Option<%s>", rustType)
	}
	return rustType
}

func inferRustReturnType(q *plugin.Query) string {
	if q.InsertIntoTable != nil {
		return pascalCase(q.InsertIntoTable.Name)
	}
	if len(q.Columns) == 1 {
		return mapToRustType(q.Columns[0].Type.Name, q.Columns[0].NotNull)
	}
	return "Row"
}
