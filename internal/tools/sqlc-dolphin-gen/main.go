package main

import (
	"bytes"
	"context"
	"database/sql"
	"flag"
	"fmt"
	"github.com/go-sql-driver/mysql"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"text/template"

	_ "github.com/go-sql-driver/mysql"
)

const catalogTmpl = `// Code generated by sqlc-dolphin-gen. DO NOT EDIT.

package {{.Pkg}}

import (
	"github.com/sqlc-dev/sqlc/internal/sql/ast"
	"github.com/sqlc-dev/sqlc/internal/sql/catalog"
)

var funcs{{.GenFnName}} = []*catalog.Function {
    {{- range .Procs}}
	{
		Name: "{{.Name}}",
		Args: []*catalog.Argument{
			{{range .Args}}{
			    Name: "{{.Name}}",
				Type: &ast.TypeName{Name: "{{.Type}}"},
				{{- if ne .Mode "IN" }}
				Mode: {{ .GoMode }},
				{{- end}}
			},
			{{end}}
		},
        {{- if ne .ReturnType "" }}
		ReturnType: &ast.TypeName{Name: "{{.ReturnType}}"},
		{{end}}
	},
	{{- end}}
}

func {{.GenFnName}}() *catalog.Schema {
	s := &catalog.Schema{Name: "{{ .SchemaName }}"}
	s.Funcs = funcs{{.GenFnName}}
	{{- if .Relations }}
	s.Tables = []*catalog.Table {
	    {{- range .Relations }}
		{
			Rel: &ast.TableName{
				Catalog: "public",
				Schema: "{{.SchemaName}}",
				Name: "{{.Name}}",
			},
			Columns: []*catalog.Column{
				{{- range .Columns}}
				{
					Name: "{{.Name}}",
					Type: ast.TypeName{Name: "{{.Type}}"},
					{{- if .IsNotNull}}
					IsNotNull: true,
					{{- end}}
					{{- if .Length }}
					Length: toPointer({{ .Length }}),
					{{- end}}
				},
				{{- end}}
			},
		},
		{{- end}}
	}
	{{- end }}
	return s
}
`

type tmplCtx struct {
	Pkg        string
	GenFnName  string
	SchemaName string
	Procs      []Proc
	Relations  []Relation
}

func main() {
	if err := run(context.Background()); err != nil {
		log.Fatal(err)
	}
}

func getEnvOrDefault(env, defaultValue string) string {
	result := os.Getenv(env)
	if result == "" {
		return defaultValue
	}
	return result
}

func databaseURL() string {
	dburl := os.Getenv("DATABASE_URL")
	if dburl != "" {
		return dburl
	}
	mysqlHost := getEnvOrDefault("MYSQL_HOST", "127.0.0.1")
	mysqlPort := getEnvOrDefault("MYSQL_PORT", "3306")

	config := mysql.Config{
		User:   getEnvOrDefault("MYSQL_USER", "root"),
		Passwd: getEnvOrDefault("MYSQL_PASSWORD", "mysecretpassword"),
		Addr:   fmt.Sprintf("%s:%s", mysqlHost, mysqlPort),
		DBName: getEnvOrDefault("MYSQL_DATABASE", ""),
	}

	return config.FormatDSN()
}

func run(ctx context.Context) error {
	flag.Parse()

	dir := flag.Arg(0)
	if dir == "" {
		dir = filepath.Join("internal", "engine", "dolphin")
	}

	tmpl, err := template.New("").Parse(catalogTmpl)
	if err != nil {
		return err
	}
	conn, err := sql.Open("mysql", databaseURL())
	if err != nil {
		return err
	}
	defer conn.Close()

	schemas := []schemaToLoad{
		{
			Name:      "mysql", // Is also mysql when running in MariaDB
			GenFnName: "genMysqlCatalog",
			DestPath:  filepath.Join(dir, "mysql_catalog.go"),
		},
		{
			Name:      "information_schema",
			GenFnName: "genInformationSchema",
			DestPath:  filepath.Join(dir, "information_schema.go"),
		},
		{
			Name:      "performance_schema",
			GenFnName: "genPerformanceSchema",
			DestPath:  filepath.Join(dir, "performance_schema.go"),
		},
		{
			Name:      "sys",
			GenFnName: "genSysSchema",
			DestPath:  filepath.Join(dir, "sys_schema.go"),
		},
	}

	for _, schema := range schemas {
		procs, err := readProcs(ctx, conn, schema.Name)
		if err != nil {
			return err
		}

		relations, err := readRelations(ctx, conn, schema.Name)
		if err != nil {
			return err
		}

		err = writeFormattedGo(tmpl, tmplCtx{
			Pkg:        "dolphin",
			SchemaName: schema.Name,
			GenFnName:  schema.GenFnName,
			Procs:      procs,
			Relations:  relations,
		}, schema.DestPath)

		if err != nil {
			return err
		}
	}

	return nil
}

// writeFormattedGo executes `tmpl` with `data` as its context to the file `destPath`
func writeFormattedGo(tmpl *template.Template, data any, destPath string) error {
	out := bytes.NewBuffer([]byte{})
	err := tmpl.Execute(out, data)
	if err != nil {
		return err
	}
	code, err := format.Source(out.Bytes())
	if err != nil {
		return err
	}

	err = os.WriteFile(destPath, code, 0644)
	if err != nil {
		return err
	}

	return nil
}

type schemaToLoad struct {
	// name is the name of a schema to load
	Name string
	// DestPath is the destination for the generate file
	DestPath string
	// The name of the function to generate for loading this schema
	GenFnName string
}
