package golang

import (
	"fmt"
	"strings"

	"github.com/sqlc-dev/sqlc/internal/codegen/sdk"
	"github.com/sqlc-dev/sqlc/internal/metadata"
	"github.com/sqlc-dev/sqlc/internal/poet"
)

// CodeGenerator generates Go source code for sqlc.
type CodeGenerator struct {
	tctx *tmplCtx
	i    *importer
}

// NewCodeGenerator creates a new code generator.
func NewCodeGenerator(tctx *tmplCtx, i *importer) *CodeGenerator {
	return &CodeGenerator{tctx: tctx, i: i}
}

// GenerateDBFile generates the db.go file content.
func (g *CodeGenerator) GenerateDBFile() ([]byte, error) {
	f := g.newFile("")
	if g.tctx.SQLDriver.IsPGX() {
		g.addDBCodePGX(f)
	} else {
		g.addDBCodeStd(f)
	}
	return poet.Render(f)
}

// GenerateModelsFile generates the models.go file content.
func (g *CodeGenerator) GenerateModelsFile() ([]byte, error) {
	f := g.newFile("")
	g.addModelsCode(f)
	return poet.Render(f)
}

// GenerateQuerierFile generates the querier.go file content.
func (g *CodeGenerator) GenerateQuerierFile() ([]byte, error) {
	f := g.newFile("")
	if g.tctx.SQLDriver.IsPGX() {
		g.addInterfaceCodePGX(f)
	} else {
		g.addInterfaceCodeStd(f)
	}
	return poet.Render(f)
}

// GenerateQueryFile generates a query source file content.
func (g *CodeGenerator) GenerateQueryFile(sourceName string) ([]byte, error) {
	f := g.newFile(sourceName)
	if g.tctx.SQLDriver.IsPGX() {
		g.addQueryCodePGX(f, sourceName)
	} else {
		g.addQueryCodeStd(f, sourceName)
	}
	return poet.Render(f)
}

// GenerateCopyFromFile generates the copyfrom.go file content.
func (g *CodeGenerator) GenerateCopyFromFile() ([]byte, error) {
	f := g.newFile(g.tctx.SourceName)
	if g.tctx.SQLDriver.IsPGX() {
		g.addCopyFromCodePGX(f)
	} else if g.tctx.SQLDriver.IsGoSQLDriverMySQL() {
		g.addCopyFromCodeMySQL(f)
	}
	return poet.Render(f)
}

// GenerateBatchFile generates the batch.go file content.
func (g *CodeGenerator) GenerateBatchFile() ([]byte, error) {
	f := g.newFile(g.tctx.SourceName)
	g.addBatchCodePGX(f)
	return poet.Render(f)
}

func (g *CodeGenerator) newFile(sourceComment string) *poet.File {
	f := &poet.File{
		BuildTags: g.tctx.BuildTags,
		Package:   g.tctx.Package,
	}

	// File comments
	f.Comments = append(f.Comments, "// Code generated by sqlc. DO NOT EDIT.")
	if !g.tctx.OmitSqlcVersion {
		f.Comments = append(f.Comments, "// versions:")
		f.Comments = append(f.Comments, "//   sqlc "+g.tctx.SqlcVersion)
	}
	if sourceComment != "" {
		f.Comments = append(f.Comments, "// source: "+sourceComment)
	}

	// Imports - two groups: stdlib and third-party, separated by blank line
	imports := g.i.Imports(g.tctx.SourceName)
	var stdlibImports, thirdPartyImports []poet.Import
	for _, imp := range imports[0] {
		stdlibImports = append(stdlibImports, poet.Import{Path: imp.Path, Alias: imp.ID})
	}
	for _, imp := range imports[1] {
		thirdPartyImports = append(thirdPartyImports, poet.Import{Path: imp.Path, Alias: imp.ID})
	}
	f.ImportGroups = [][]poet.Import{stdlibImports, thirdPartyImports}

	return f
}

func (g *CodeGenerator) addDBCodeStd(f *poet.File) {
	// DBTX interface
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "DBTX",
		Type: poet.Interface{
			Methods: []poet.Method{
				{Name: "ExecContext", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "sql.Result"}, {Type: "error"}}},
				{Name: "PrepareContext", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}}, Results: []poet.Param{{Type: "*sql.Stmt"}, {Type: "error"}}},
				{Name: "QueryContext", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "*sql.Rows"}, {Type: "error"}}},
				{Name: "QueryRowContext", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "*sql.Row"}}},
			},
		},
	})

	// New function
	if g.tctx.EmitMethodsWithDBArgument {
		f.Decls = append(f.Decls, poet.Func{
			Name:    "New",
			Results: []poet.Param{{Type: "*Queries"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: "\treturn &Queries{}\n"}},
		})
	} else {
		f.Decls = append(f.Decls, poet.Func{
			Name:    "New",
			Params:  []poet.Param{{Name: "db", Type: "DBTX"}},
			Results: []poet.Param{{Type: "*Queries"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: "\treturn &Queries{db: db}\n"}},
		})
	}

	// Prepare and Close functions for prepared queries
	if g.tctx.EmitPreparedQueries {
		var prepareBody strings.Builder
		prepareBody.WriteString("\tq := Queries{db: db}\n")
		prepareBody.WriteString("\tvar err error\n")
		if len(g.tctx.GoQueries) == 0 {
			prepareBody.WriteString("\t_ = err\n")
		}
		for _, query := range g.tctx.GoQueries {
			fmt.Fprintf(&prepareBody, "\tif q.%s, err = db.PrepareContext(ctx, %s); err != nil {\n", query.FieldName, query.ConstantName)
			fmt.Fprintf(&prepareBody, "\t\treturn nil, fmt.Errorf(\"error preparing query %s: %%w\", err)\n", query.MethodName)
			prepareBody.WriteString("\t}\n")
		}
		prepareBody.WriteString("\treturn &q, nil\n")

		f.Decls = append(f.Decls, poet.Func{
			Name:    "Prepare",
			Params:  []poet.Param{{Name: "ctx", Type: "context.Context"}, {Name: "db", Type: "DBTX"}},
			Results: []poet.Param{{Type: "*Queries"}, {Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: prepareBody.String()}},
		})

		var closeBody strings.Builder
		closeBody.WriteString("\tvar err error\n")
		for _, query := range g.tctx.GoQueries {
			fmt.Fprintf(&closeBody, "\tif q.%s != nil {\n", query.FieldName)
			fmt.Fprintf(&closeBody, "\t\tif cerr := q.%s.Close(); cerr != nil {\n", query.FieldName)
			fmt.Fprintf(&closeBody, "\t\t\terr = fmt.Errorf(\"error closing %s: %%w\", cerr)\n", query.FieldName)
			closeBody.WriteString("\t\t}\n\t}\n")
		}
		closeBody.WriteString("\treturn err\n")

		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    "Close",
			Results: []poet.Param{{Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: closeBody.String()}},
		})

		// Helper functions
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    "exec",
			Params:  []poet.Param{{Name: "ctx", Type: "context.Context"}, {Name: "stmt", Type: "*sql.Stmt"}, {Name: "query", Type: "string"}, {Name: "args", Type: "...interface{}"}},
			Results: []poet.Param{{Type: "sql.Result"}, {Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: `	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
`}},
		})

		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    "query",
			Params:  []poet.Param{{Name: "ctx", Type: "context.Context"}, {Name: "stmt", Type: "*sql.Stmt"}, {Name: "query", Type: "string"}, {Name: "args", Type: "...interface{}"}},
			Results: []poet.Param{{Type: "*sql.Rows"}, {Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: `	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
`}},
		})

		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    "queryRow",
			Params:  []poet.Param{{Name: "ctx", Type: "context.Context"}, {Name: "stmt", Type: "*sql.Stmt"}, {Name: "query", Type: "string"}, {Name: "args", Type: "...interface{}"}},
			Results: []poet.Param{{Type: "*sql.Row"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: `	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
`}},
		})
	}

	// Queries struct
	var fields []poet.Field
	if !g.tctx.EmitMethodsWithDBArgument {
		fields = append(fields, poet.Field{Name: "db", Type: "DBTX"})
	}
	if g.tctx.EmitPreparedQueries {
		fields = append(fields, poet.Field{Name: "tx", Type: "*sql.Tx"})
		for _, query := range g.tctx.GoQueries {
			fields = append(fields, poet.Field{Name: query.FieldName, Type: "*sql.Stmt"})
		}
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "Queries",
		Type: poet.Struct{Fields: fields},
	})

	// WithTx method
	if !g.tctx.EmitMethodsWithDBArgument {
		var withTxBody strings.Builder
		withTxBody.WriteString("\treturn &Queries{\n")
		withTxBody.WriteString("\t\tdb: tx,\n")
		if g.tctx.EmitPreparedQueries {
			withTxBody.WriteString("\t\ttx: tx,\n")
			for _, query := range g.tctx.GoQueries {
				fmt.Fprintf(&withTxBody, "\t\t%s: q.%s,\n", query.FieldName, query.FieldName)
			}
		}
		withTxBody.WriteString("\t}\n")

		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    "WithTx",
			Params:  []poet.Param{{Name: "tx", Type: "*sql.Tx"}},
			Results: []poet.Param{{Type: "*Queries"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: withTxBody.String()}},
		})
	}
}

func (g *CodeGenerator) addDBCodePGX(f *poet.File) {
	// DBTX interface
	methods := []poet.Method{
		{Name: "Exec", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "pgconn.CommandTag"}, {Type: "error"}}},
		{Name: "Query", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "pgx.Rows"}, {Type: "error"}}},
		{Name: "QueryRow", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "pgx.Row"}}},
	}
	if g.tctx.UsesCopyFrom {
		methods = append(methods, poet.Method{
			Name:    "CopyFrom",
			Params:  []poet.Param{{Name: "ctx", Type: "context.Context"}, {Name: "tableName", Type: "pgx.Identifier"}, {Name: "columnNames", Type: "[]string"}, {Name: "rowSrc", Type: "pgx.CopyFromSource"}},
			Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
		})
	}
	if g.tctx.UsesBatch {
		methods = append(methods, poet.Method{
			Name:    "SendBatch",
			Params:  []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "*pgx.Batch"}},
			Results: []poet.Param{{Type: "pgx.BatchResults"}},
		})
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "DBTX",
		Type: poet.Interface{Methods: methods},
	})

	// New function
	if g.tctx.EmitMethodsWithDBArgument {
		f.Decls = append(f.Decls, poet.Func{
			Name:    "New",
			Results: []poet.Param{{Type: "*Queries"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: "\treturn &Queries{}\n"}},
		})
	} else {
		f.Decls = append(f.Decls, poet.Func{
			Name:    "New",
			Params:  []poet.Param{{Name: "db", Type: "DBTX"}},
			Results: []poet.Param{{Type: "*Queries"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: "\treturn &Queries{db: db}\n"}},
		})
	}

	// Queries struct
	var fields []poet.Field
	if !g.tctx.EmitMethodsWithDBArgument {
		fields = append(fields, poet.Field{Name: "db", Type: "DBTX"})
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "Queries",
		Type: poet.Struct{Fields: fields},
	})

	// WithTx method
	if !g.tctx.EmitMethodsWithDBArgument {
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    "WithTx",
			Params:  []poet.Param{{Name: "tx", Type: "pgx.Tx"}},
			Results: []poet.Param{{Type: "*Queries"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: "\treturn &Queries{\n\t\tdb: tx,\n\t}\n"}},
		})
	}
}

func (g *CodeGenerator) addModelsCode(f *poet.File) {
	// Enums
	for _, enum := range g.tctx.Enums {
		// Type alias
		f.Decls = append(f.Decls, poet.TypeDef{
			Comment: enum.Comment,
			Name:    enum.Name,
			Type:    poet.TypeName{Name: "string"},
		})

		// Constants
		var consts []poet.Const
		for _, c := range enum.Constants {
			consts = append(consts, poet.Const{
				Name:  c.Name,
				Type:  c.Type,
				Value: fmt.Sprintf("%q", c.Value),
			})
		}
		f.Decls = append(f.Decls, poet.ConstBlock{Consts: consts})

		// Scan method
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "e", Type: "*" + enum.Name},
			Name:    "Scan",
			Params:  []poet.Param{{Name: "src", Type: "interface{}"}},
			Results: []poet.Param{{Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: fmt.Sprintf(`	switch s := src.(type) {
	case []byte:
		*e = %s(s)
	case string:
		*e = %s(s)
	default:
		return fmt.Errorf("unsupported scan type for %s: %%T", src)
	}
	return nil
`, enum.Name, enum.Name, enum.Name)}},
		})

		// Null type
		var nullFields []poet.Field
		if enum.NameTag() != "" {
			nullFields = append(nullFields, poet.Field{Name: enum.Name, Type: enum.Name, Tag: enum.NameTag()})
		} else {
			nullFields = append(nullFields, poet.Field{Name: enum.Name, Type: enum.Name})
		}
		if enum.ValidTag() != "" {
			nullFields = append(nullFields, poet.Field{Name: "Valid", Type: "bool", Tag: enum.ValidTag(), TrailingComment: fmt.Sprintf("Valid is true if %s is not NULL", enum.Name)})
		} else {
			nullFields = append(nullFields, poet.Field{Name: "Valid", Type: "bool", TrailingComment: fmt.Sprintf("Valid is true if %s is not NULL", enum.Name)})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: "Null" + enum.Name,
			Type: poet.Struct{Fields: nullFields},
		})

		// Null Scan method
		f.Decls = append(f.Decls, poet.Func{
			Comment: "Scan implements the Scanner interface.",
			Recv:    &poet.Param{Name: "ns", Type: "*Null" + enum.Name},
			Name:    "Scan",
			Params:  []poet.Param{{Name: "value", Type: "interface{}"}},
			Results: []poet.Param{{Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: fmt.Sprintf(`	if value == nil {
		ns.%s, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.%s.Scan(value)
`, enum.Name, enum.Name)}},
		})

		// Null Value method
		f.Decls = append(f.Decls, poet.Func{
			Comment: "Value implements the driver Valuer interface.",
			Recv:    &poet.Param{Name: "ns", Type: "Null" + enum.Name},
			Name:    "Value",
			Results: []poet.Param{{Type: "driver.Value"}, {Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: fmt.Sprintf(`	if !ns.Valid {
		return nil, nil
	}
	return string(ns.%s), nil
`, enum.Name)}},
		})

		// Valid method
		if g.tctx.EmitEnumValidMethod {
			var caseList strings.Builder
			for i, c := range enum.Constants {
				if i > 0 {
					caseList.WriteString(",\n\t\t")
				}
				caseList.WriteString(c.Name)
			}
			f.Decls = append(f.Decls, poet.Func{
				Recv:    &poet.Param{Name: "e", Type: enum.Name},
				Name:    "Valid",
				Results: []poet.Param{{Type: "bool"}},
				Stmts: []poet.Stmt{poet.RawStmt{Code: fmt.Sprintf(`	switch e {
	case %s:
		return true
	}
	return false
`, caseList.String())}},
			})
		}

		// AllValues method
		if g.tctx.EmitAllEnumValues {
			var valuesList strings.Builder
			for _, c := range enum.Constants {
				fmt.Fprintf(&valuesList, "\t\t%s,\n", c.Name)
			}
			f.Decls = append(f.Decls, poet.Func{
				Name:    fmt.Sprintf("All%sValues", enum.Name),
				Results: []poet.Param{{Type: "[]" + enum.Name}},
				Stmts:   []poet.Stmt{poet.RawStmt{Code: fmt.Sprintf("\treturn []%s{\n%s\t}\n", enum.Name, valuesList.String())}},
			})
		}
	}

	// Structs
	for _, s := range g.tctx.Structs {
		var fields []poet.Field
		for _, fld := range s.Fields {
			fields = append(fields, poet.Field{
				Comment: fld.Comment,
				Name:    fld.Name,
				Type:    fld.Type,
				Tag:     fld.Tag(),
			})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Comment: s.Comment,
			Name:    s.Name,
			Type:    poet.Struct{Fields: fields},
		})
	}
}

func (g *CodeGenerator) addInterfaceCodeStd(f *poet.File) {
	var methods []poet.Method
	for _, q := range g.tctx.GoQueries {
		m := g.buildInterfaceMethod(q, false)
		if m != nil {
			methods = append(methods, *m)
		}
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "Querier",
		Type: poet.Interface{Methods: methods},
	})
	f.Decls = append(f.Decls, poet.Var{
		Name:  "_",
		Type:  "Querier",
		Value: "(*Queries)(nil)",
	})
}

func (g *CodeGenerator) addInterfaceCodePGX(f *poet.File) {
	var methods []poet.Method
	for _, q := range g.tctx.GoQueries {
		m := g.buildInterfaceMethod(q, true)
		if m != nil {
			methods = append(methods, *m)
		}
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "Querier",
		Type: poet.Interface{Methods: methods},
	})
	f.Decls = append(f.Decls, poet.Var{
		Name:  "_",
		Type:  "Querier",
		Value: "(*Queries)(nil)",
	})
}

func (g *CodeGenerator) buildInterfaceMethod(q Query, isPGX bool) *poet.Method {
	var params string
	var returnType string

	switch q.Cmd {
	case ":one":
		params = q.Arg.Pair()
		returnType = fmt.Sprintf("(%s, error)", q.Ret.DefineType())
	case ":many":
		params = q.Arg.Pair()
		returnType = fmt.Sprintf("([]%s, error)", q.Ret.DefineType())
	case ":exec":
		params = q.Arg.Pair()
		returnType = "error"
	case ":execrows":
		params = q.Arg.Pair()
		returnType = "(int64, error)"
	case ":execlastid":
		params = q.Arg.Pair()
		returnType = "(int64, error)"
	case ":execresult":
		params = q.Arg.Pair()
		if isPGX {
			returnType = "(pgconn.CommandTag, error)"
		} else {
			returnType = "(sql.Result, error)"
		}
	case ":copyfrom":
		params = q.Arg.SlicePair()
		returnType = "(int64, error)"
	case ":batchexec", ":batchmany", ":batchone":
		params = q.Arg.SlicePair()
		returnType = fmt.Sprintf("*%sBatchResults", q.MethodName)
	default:
		return nil
	}

	if g.tctx.EmitMethodsWithDBArgument {
		if params != "" {
			params = "db DBTX, " + params
		} else {
			params = "db DBTX"
		}
	}

	comment := ""
	for _, c := range q.Comments {
		comment += "//" + c + "\n"
	}
	comment = strings.TrimSuffix(comment, "\n")

	// Build params list
	var paramList []poet.Param
	paramList = append(paramList, poet.Param{Name: "ctx", Type: "context.Context"})
	if params != "" {
		paramList = append(paramList, poet.Param{Name: "", Type: params})
	}

	return &poet.Method{
		Comment: comment,
		Name:    q.MethodName,
		Params:  paramList,
		Results: []poet.Param{{Type: returnType}},
	}
}

func (g *CodeGenerator) addQueryCodeStd(f *poet.File, sourceName string) {
	for _, q := range g.tctx.GoQueries {
		if q.SourceName != sourceName {
			continue
		}
		g.addQueryStd(f, q)
	}
}

func (g *CodeGenerator) addQueryStd(f *poet.File, q Query) {
	// SQL constant
	f.Decls = append(f.Decls, poet.Const{
		Name:  q.ConstantName,
		Value: fmt.Sprintf("`-- name: %s %s\n%s\n`", q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL)),
	})

	// Arg struct if needed
	if q.Arg.EmitStruct() {
		var fields []poet.Field
		for _, fld := range q.Arg.UniqueFields() {
			fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.Arg.Type(),
			Type: poet.Struct{Fields: fields},
		})
	}

	// Ret struct if needed
	if q.Ret.EmitStruct() {
		var fields []poet.Field
		for _, fld := range q.Ret.Struct.Fields {
			fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.Ret.Type(),
			Type: poet.Struct{Fields: fields},
		})
	}

	// Method
	switch q.Cmd {
	case ":one":
		g.addQueryOneStd(f, q)
	case ":many":
		g.addQueryManyStd(f, q)
	case ":exec":
		g.addQueryExecStd(f, q)
	case ":execrows":
		g.addQueryExecRowsStd(f, q)
	case ":execlastid":
		g.addQueryExecLastIDStd(f, q)
	case ":execresult":
		g.addQueryExecResultStd(f, q)
	}
}

func (g *CodeGenerator) queryComments(q Query) string {
	var comment string
	for _, c := range q.Comments {
		comment += "//" + c + "\n"
	}
	return strings.TrimSuffix(comment, "\n")
}

func (g *CodeGenerator) addQueryOneStd(f *poet.File, q Query) {
	var body strings.Builder
	g.writeQueryExecStdCall(&body, q, "row :=")

	if q.Arg.Pair() != q.Ret.Pair() || q.Arg.DefineType() != q.Ret.DefineType() {
		fmt.Fprintf(&body, "\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	}

	fmt.Fprintf(&body, "\terr := row.Scan(%s)\n", q.Ret.Scan())

	if g.tctx.WrapErrors {
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
	}

	fmt.Fprintf(&body, "\treturn %s, err\n", q.Ret.ReturnName())

	params := g.buildQueryParams(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: q.Ret.DefineType()}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryManyStd(f *poet.File, q Query) {
	var body strings.Builder
	g.writeQueryExecStdCall(&body, q, "rows, err :=")

	body.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn nil, err\n")
	}
	body.WriteString("\t}\n")
	body.WriteString("\tdefer rows.Close()\n")

	if g.tctx.EmitEmptySlices {
		fmt.Fprintf(&body, "\titems := []%s{}\n", q.Ret.DefineType())
	} else {
		fmt.Fprintf(&body, "\tvar items []%s\n", q.Ret.DefineType())
	}

	body.WriteString("\tfor rows.Next() {\n")
	fmt.Fprintf(&body, "\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	fmt.Fprintf(&body, "\t\tif err := rows.Scan(%s); err != nil {\n", q.Ret.Scan())
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\t\treturn nil, err\n")
	}
	body.WriteString("\t\t}\n")
	fmt.Fprintf(&body, "\t\titems = append(items, %s)\n", q.Ret.ReturnName())
	body.WriteString("\t}\n")

	body.WriteString("\tif err := rows.Close(); err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn nil, err\n")
	}
	body.WriteString("\t}\n")

	body.WriteString("\tif err := rows.Err(); err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn nil, err\n")
	}
	body.WriteString("\t}\n")

	body.WriteString("\treturn items, nil\n")

	params := g.buildQueryParams(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "[]" + q.Ret.DefineType()}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecStd(f *poet.File, q Query) {
	var body strings.Builder
	g.writeQueryExecStdCall(&body, q, "_, err :=")

	if g.tctx.WrapErrors {
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
	}
	body.WriteString("\treturn err\n")

	params := g.buildQueryParams(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecRowsStd(f *poet.File, q Query) {
	var body strings.Builder
	g.writeQueryExecStdCall(&body, q, "result, err :=")

	body.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn 0, err\n")
	}
	body.WriteString("\t}\n")
	body.WriteString("\treturn result.RowsAffected()\n")

	params := g.buildQueryParams(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecLastIDStd(f *poet.File, q Query) {
	var body strings.Builder
	g.writeQueryExecStdCall(&body, q, "result, err :=")

	body.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn 0, err\n")
	}
	body.WriteString("\t}\n")
	body.WriteString("\treturn result.LastInsertId()\n")

	params := g.buildQueryParams(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecResultStd(f *poet.File, q Query) {
	var body strings.Builder

	if g.tctx.WrapErrors {
		g.writeQueryExecStdCall(&body, q, "result, err :=")
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
		body.WriteString("\treturn result, err\n")
	} else {
		g.writeQueryExecStdCall(&body, q, "return")
	}

	params := g.buildQueryParams(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "sql.Result"}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) buildQueryParams(q Query) []poet.Param {
	var params []poet.Param
	params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
	if g.tctx.EmitMethodsWithDBArgument {
		params = append(params, poet.Param{Name: "db", Type: "DBTX"})
	}
	if q.Arg.Pair() != "" {
		// Parse the pair into name and type
		pair := q.Arg.Pair()
		if pair != "" {
			params = append(params, poet.Param{Name: "", Type: pair})
		}
	}
	return params
}

func (g *CodeGenerator) writeQueryExecStdCall(body *strings.Builder, q Query, retval string) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	if q.Arg.HasSqlcSlices() {
		g.writeQuerySliceExec(body, q, retval, db, false)
		return
	}

	var method string
	switch q.Cmd {
	case ":one":
		if g.tctx.EmitPreparedQueries {
			method = "q.queryRow"
		} else {
			method = db + ".QueryRowContext"
		}
	case ":many":
		if g.tctx.EmitPreparedQueries {
			method = "q.query"
		} else {
			method = db + ".QueryContext"
		}
	default:
		if g.tctx.EmitPreparedQueries {
			method = "q.exec"
		} else {
			method = db + ".ExecContext"
		}
	}

	if g.tctx.EmitPreparedQueries {
		params := q.Arg.Params()
		if params != "" {
			params = ", " + params
		}
		fmt.Fprintf(body, "\t%s %s(ctx, q.%s, %s%s)\n", retval, method, q.FieldName, q.ConstantName, params)
	} else {
		params := q.Arg.Params()
		if params != "" {
			params = ", " + params
		}
		fmt.Fprintf(body, "\t%s %s(ctx, %s%s)\n", retval, method, q.ConstantName, params)
	}
}

func (g *CodeGenerator) writeQuerySliceExec(body *strings.Builder, q Query, retval, db string, isPGX bool) {
	body.WriteString("\tquery := " + q.ConstantName + "\n")
	body.WriteString("\tvar queryParams []interface{}\n")

	if q.Arg.Struct != nil {
		for _, fld := range q.Arg.Struct.Fields {
			varName := q.Arg.VariableForField(fld)
			if fld.HasSqlcSlice() {
				fmt.Fprintf(body, "\tif len(%s) > 0 {\n", varName)
				fmt.Fprintf(body, "\t\tfor _, v := range %s {\n", varName)
				body.WriteString("\t\t\tqueryParams = append(queryParams, v)\n")
				body.WriteString("\t\t}\n")
				fmt.Fprintf(body, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , strings.Repeat(\",?\", len(%s))[1:], 1)\n", fld.Column.Name, varName)
				body.WriteString("\t} else {\n")
				fmt.Fprintf(body, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , \"NULL\", 1)\n", fld.Column.Name)
				body.WriteString("\t}\n")
			} else {
				fmt.Fprintf(body, "\tqueryParams = append(queryParams, %s)\n", varName)
			}
		}
	} else {
		argName := q.Arg.Name
		colName := q.Arg.Column.Name
		fmt.Fprintf(body, "\tif len(%s) > 0 {\n", argName)
		fmt.Fprintf(body, "\t\tfor _, v := range %s {\n", argName)
		body.WriteString("\t\t\tqueryParams = append(queryParams, v)\n")
		body.WriteString("\t\t}\n")
		fmt.Fprintf(body, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , strings.Repeat(\",?\", len(%s))[1:], 1)\n", colName, argName)
		body.WriteString("\t} else {\n")
		fmt.Fprintf(body, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , \"NULL\", 1)\n", colName)
		body.WriteString("\t}\n")
	}

	var method string
	switch q.Cmd {
	case ":one":
		if g.tctx.EmitPreparedQueries {
			method = "q.queryRow"
		} else {
			method = db + ".QueryRowContext"
		}
	case ":many":
		if g.tctx.EmitPreparedQueries {
			method = "q.query"
		} else {
			method = db + ".QueryContext"
		}
	default:
		if g.tctx.EmitPreparedQueries {
			method = "q.exec"
		} else {
			method = db + ".ExecContext"
		}
	}

	if g.tctx.EmitPreparedQueries {
		fmt.Fprintf(body, "\t%s %s(ctx, nil, query, queryParams...)\n", retval, method)
	} else {
		fmt.Fprintf(body, "\t%s %s(ctx, query, queryParams...)\n", retval, method)
	}
}

func (g *CodeGenerator) addQueryCodePGX(f *poet.File, sourceName string) {
	for _, q := range g.tctx.GoQueries {
		if q.SourceName != sourceName {
			continue
		}
		if strings.HasPrefix(q.Cmd, ":batch") {
			// Batch queries are fully handled in batch.go
			continue
		}
		if q.Cmd == metadata.CmdCopyFrom {
			// For copyfrom, only emit the struct definition (implementation is in copyfrom.go)
			if q.Arg.EmitStruct() {
				var fields []poet.Field
				for _, fld := range q.Arg.Struct.Fields {
					fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
				}
				f.Decls = append(f.Decls, poet.TypeDef{
					Name: q.Arg.Type(),
					Type: poet.Struct{Fields: fields},
				})
			}
			continue
		}
		g.addQueryPGX(f, q)
	}
}

func (g *CodeGenerator) addQueryPGX(f *poet.File, q Query) {
	// SQL constant
	f.Decls = append(f.Decls, poet.Const{
		Name:  q.ConstantName,
		Value: fmt.Sprintf("`-- name: %s %s\n%s\n`", q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL)),
	})

	// Arg struct if needed
	if q.Arg.EmitStruct() {
		var fields []poet.Field
		for _, fld := range q.Arg.Struct.Fields {
			fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.Arg.Type(),
			Type: poet.Struct{Fields: fields},
		})
	}

	// Ret struct if needed
	if q.Ret.EmitStruct() {
		var fields []poet.Field
		for _, fld := range q.Ret.Struct.Fields {
			fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.Ret.Type(),
			Type: poet.Struct{Fields: fields},
		})
	}

	// Method
	switch q.Cmd {
	case ":one":
		g.addQueryOnePGX(f, q)
	case ":many":
		g.addQueryManyPGX(f, q)
	case ":exec":
		g.addQueryExecPGX(f, q)
	case ":execrows":
		g.addQueryExecRowsPGX(f, q)
	case ":execresult":
		g.addQueryExecResultPGX(f, q)
	}
}

func (g *CodeGenerator) buildQueryParamsPGX(q Query) []poet.Param {
	var params []poet.Param
	params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
	if g.tctx.EmitMethodsWithDBArgument {
		params = append(params, poet.Param{Name: "db", Type: "DBTX"})
	}
	if q.Arg.Pair() != "" {
		params = append(params, poet.Param{Name: "", Type: q.Arg.Pair()})
	}
	return params
}

func (g *CodeGenerator) addQueryOnePGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}
	fmt.Fprintf(&body, "\trow := %s.QueryRow(ctx, %s%s)\n", db, q.ConstantName, qParams)

	if q.Arg.Pair() != q.Ret.Pair() || q.Arg.DefineType() != q.Ret.DefineType() {
		fmt.Fprintf(&body, "\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	}

	fmt.Fprintf(&body, "\terr := row.Scan(%s)\n", q.Ret.Scan())

	if g.tctx.WrapErrors {
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
	}

	fmt.Fprintf(&body, "\treturn %s, err\n", q.Ret.ReturnName())

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: q.Ret.DefineType()}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryManyPGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}
	fmt.Fprintf(&body, "\trows, err := %s.Query(ctx, %s%s)\n", db, q.ConstantName, qParams)

	body.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn nil, err\n")
	}
	body.WriteString("\t}\n")
	body.WriteString("\tdefer rows.Close()\n")

	if g.tctx.EmitEmptySlices {
		fmt.Fprintf(&body, "\titems := []%s{}\n", q.Ret.DefineType())
	} else {
		fmt.Fprintf(&body, "\tvar items []%s\n", q.Ret.DefineType())
	}

	body.WriteString("\tfor rows.Next() {\n")
	fmt.Fprintf(&body, "\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	fmt.Fprintf(&body, "\t\tif err := rows.Scan(%s); err != nil {\n", q.Ret.Scan())
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\t\treturn nil, err\n")
	}
	body.WriteString("\t\t}\n")
	fmt.Fprintf(&body, "\t\titems = append(items, %s)\n", q.Ret.ReturnName())
	body.WriteString("\t}\n")

	body.WriteString("\tif err := rows.Err(); err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn nil, err\n")
	}
	body.WriteString("\t}\n")

	body.WriteString("\treturn items, nil\n")

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "[]" + q.Ret.DefineType()}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecPGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}
	fmt.Fprintf(&body, "\t_, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, qParams)

	if g.tctx.WrapErrors {
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\treturn fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
		body.WriteString("\treturn nil\n")
	} else {
		body.WriteString("\treturn err\n")
	}

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecRowsPGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}
	fmt.Fprintf(&body, "\tresult, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, qParams)

	body.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn 0, err\n")
	}
	body.WriteString("\t}\n")
	body.WriteString("\treturn result.RowsAffected(), nil\n")

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecResultPGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}

	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\tresult, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, qParams)
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
		body.WriteString("\treturn result, err\n")
	} else {
		fmt.Fprintf(&body, "\treturn %s.Exec(ctx, %s%s)\n", db, q.ConstantName, qParams)
	}

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "pgconn.CommandTag"}, {Type: "error"}},
		Stmts: []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addCopyFromCodePGX(f *poet.File) {
	for _, q := range g.tctx.GoQueries {
		if q.Cmd != metadata.CmdCopyFrom {
			continue
		}

		iterName := "iteratorFor" + q.MethodName

		// Iterator struct
		f.Decls = append(f.Decls, poet.TypeDef{
			Comment: fmt.Sprintf("iteratorFor%s implements pgx.CopyFromSource.", q.MethodName),
			Name:    iterName,
			Type: poet.Struct{
				Fields: []poet.Field{
					{Name: "rows", Type: "[]" + q.Arg.DefineType()},
					{Name: "skippedFirstNextCall", Type: "bool"},
				},
			},
		})

		// Next method
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "r", Type: "*" + iterName},
			Name:    "Next",
			Results: []poet.Param{{Type: "bool"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: `	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
`}},
		})

		// Values method
		var valuesBody strings.Builder
		valuesBody.WriteString("\treturn []interface{}{\n")
		if q.Arg.Struct != nil {
			for _, fld := range q.Arg.Struct.Fields {
				fmt.Fprintf(&valuesBody, "\t\tr.rows[0].%s,\n", fld.Name)
			}
		} else {
			valuesBody.WriteString("\t\tr.rows[0],\n")
		}
		valuesBody.WriteString("\t}, nil\n")

		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "r", Type: iterName},
			Name:    "Values",
			Results: []poet.Param{{Type: "[]interface{}"}, {Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: valuesBody.String()}},
		})

		// Err method
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "r", Type: iterName},
			Name:    "Err",
			Results: []poet.Param{{Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: "\treturn nil\n"}},
		})

		// Main method
		db := "q.db"
		var params []poet.Param
		params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			params = append(params, poet.Param{Name: "db", Type: "DBTX"})
		}
		params = append(params, poet.Param{Name: "", Type: q.Arg.SlicePair()})

		body := fmt.Sprintf("\treturn %s.CopyFrom(ctx, %s, %s, &%s{rows: %s})\n",
			db, q.TableIdentifierAsGoSlice(), q.Arg.ColumnNamesAsGoSlice(), iterName, q.Arg.Name)

		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: body}},
		})
	}
}

func (g *CodeGenerator) addCopyFromCodeMySQL(f *poet.File) {
	for _, q := range g.tctx.GoQueries {
		if q.Cmd != metadata.CmdCopyFrom {
			continue
		}

		// Reader handler sequence
		f.Decls = append(f.Decls, poet.Var{
			Name:  fmt.Sprintf("readerHandlerSequenceFor%s", q.MethodName),
			Type:  "uint32",
			Value: "1",
		})

		// Convert rows function
		var convertBody strings.Builder
		fmt.Fprintf(&convertBody, "\te := mysqltsv.NewEncoder(w, %d, nil)\n", len(q.Arg.CopyFromMySQLFields()))
		fmt.Fprintf(&convertBody, "\tfor _, row := range %s {\n", q.Arg.Name)

		for _, fld := range q.Arg.CopyFromMySQLFields() {
			accessor := "row"
			if q.Arg.Struct != nil {
				accessor = "row." + fld.Name
			}
			switch fld.Type {
			case "string":
				fmt.Fprintf(&convertBody, "\t\te.AppendString(%s)\n", accessor)
			case "[]byte", "json.RawMessage":
				fmt.Fprintf(&convertBody, "\t\te.AppendBytes(%s)\n", accessor)
			default:
				fmt.Fprintf(&convertBody, "\t\te.AppendValue(%s)\n", accessor)
			}
		}

		convertBody.WriteString("\t}\n")
		convertBody.WriteString("\tw.CloseWithError(e.Close())\n")

		f.Decls = append(f.Decls, poet.Func{
			Name:   fmt.Sprintf("convertRowsFor%s", q.MethodName),
			Params: []poet.Param{{Name: "w", Type: "*io.PipeWriter"}, {Name: "", Type: q.Arg.SlicePair()}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: convertBody.String()}},
		})

		// Main method
		db := "q.db"
		var params []poet.Param
		params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			params = append(params, poet.Param{Name: "db", Type: "DBTX"})
		}
		params = append(params, poet.Param{Name: "", Type: q.Arg.SlicePair()})

		var colNames []string
		for _, name := range q.Arg.ColumnNames() {
			colNames = append(colNames, name)
		}
		colList := strings.Join(colNames, ", ")

		var mainBody strings.Builder
		mainBody.WriteString("\tpr, pw := io.Pipe()\n")
		mainBody.WriteString("\tdefer pr.Close()\n")
		fmt.Fprintf(&mainBody, "\trh := fmt.Sprintf(\"%s_%%d\", atomic.AddUint32(&readerHandlerSequenceFor%s, 1))\n", q.MethodName, q.MethodName)
		mainBody.WriteString("\tmysql.RegisterReaderHandler(rh, func() io.Reader { return pr })\n")
		mainBody.WriteString("\tdefer mysql.DeregisterReaderHandler(rh)\n")
		fmt.Fprintf(&mainBody, "\tgo convertRowsFor%s(pw, %s)\n", q.MethodName, q.Arg.Name)
		mainBody.WriteString("\t// The string interpolation is necessary because LOAD DATA INFILE requires\n")
		mainBody.WriteString("\t// the file name to be given as a literal string.\n")
		fmt.Fprintf(&mainBody, "\tresult, err := %s.ExecContext(ctx, fmt.Sprintf(\"LOAD DATA LOCAL INFILE '%%s' INTO TABLE %s %%s (%s)\", \"Reader::\"+rh, mysqltsv.Escaping))\n",
			db, q.TableIdentifierForMySQL(), colList)
		mainBody.WriteString("\tif err != nil {\n")
		mainBody.WriteString("\t\treturn 0, err\n")
		mainBody.WriteString("\t}\n")
		mainBody.WriteString("\treturn result.RowsAffected()\n")

		comment := g.queryComments(q)
		comment += fmt.Sprintf("\n// %s uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.", q.MethodName)
		comment += "\n//\n// Errors and duplicate keys are treated as warnings and insertion will"
		comment += "\n// continue, even without an error for some cases.  Use this in a transaction"
		comment += "\n// and use SHOW WARNINGS to check for any problems and roll back if you want to."
		comment += "\n//\n// Check the documentation for more information:"
		comment += "\n// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling"

		f.Decls = append(f.Decls, poet.Func{
			Comment: comment,
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: mainBody.String()}},
		})
	}
}

func (g *CodeGenerator) addBatchCodePGX(f *poet.File) {
	// Error variable
	f.Decls = append(f.Decls, poet.VarBlock{
		Vars: []poet.Var{
			{Name: "ErrBatchAlreadyClosed", Value: `errors.New("batch already closed")`},
		},
	})

	for _, q := range g.tctx.GoQueries {
		if !strings.HasPrefix(q.Cmd, ":batch") {
			continue
		}

		// SQL constant
		f.Decls = append(f.Decls, poet.Const{
			Name:  q.ConstantName,
			Value: fmt.Sprintf("`-- name: %s %s\n%s\n`", q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL)),
		})

		// BatchResults struct
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.MethodName + "BatchResults",
			Type: poet.Struct{
				Fields: []poet.Field{
					{Name: "br", Type: "pgx.BatchResults"},
					{Name: "tot", Type: "int"},
					{Name: "closed", Type: "bool"},
				},
			},
		})

		// Arg struct if needed
		if q.Arg.Struct != nil {
			var fields []poet.Field
			for _, fld := range q.Arg.Struct.Fields {
				fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
			}
			f.Decls = append(f.Decls, poet.TypeDef{
				Name: q.Arg.Type(),
				Type: poet.Struct{Fields: fields},
			})
		}

		// Ret struct if needed
		if q.Ret.EmitStruct() {
			var fields []poet.Field
			for _, fld := range q.Ret.Struct.Fields {
				fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
			}
			f.Decls = append(f.Decls, poet.TypeDef{
				Name: q.Ret.Type(),
				Type: poet.Struct{Fields: fields},
			})
		}

		// Main batch method
		db := "q.db"
		var params []poet.Param
		params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			params = append(params, poet.Param{Name: "db", Type: "DBTX"})
		}
		params = append(params, poet.Param{Name: "", Type: q.Arg.SlicePair()})

		var mainBody strings.Builder
		mainBody.WriteString("\tbatch := &pgx.Batch{}\n")
		fmt.Fprintf(&mainBody, "\tfor _, a := range %s {\n", q.Arg.Name)
		mainBody.WriteString("\t\tvals := []interface{}{\n")
		if q.Arg.Struct != nil {
			for _, fld := range q.Arg.Struct.Fields {
				fmt.Fprintf(&mainBody, "\t\t\ta.%s,\n", fld.Name)
			}
		} else {
			mainBody.WriteString("\t\t\ta,\n")
		}
		mainBody.WriteString("\t\t}\n")
		fmt.Fprintf(&mainBody, "\t\tbatch.Queue(%s, vals...)\n", q.ConstantName)
		mainBody.WriteString("\t}\n")
		fmt.Fprintf(&mainBody, "\tbr := %s.SendBatch(ctx, batch)\n", db)
		fmt.Fprintf(&mainBody, "\treturn &%sBatchResults{br, len(%s), false}\n", q.MethodName, q.Arg.Name)

		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "*" + q.MethodName + "BatchResults"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: mainBody.String()}},
		})

		// Result method based on command type
		switch q.Cmd {
		case ":batchexec":
			f.Decls = append(f.Decls, poet.Func{
				Recv:   &poet.Param{Name: "b", Type: "*" + q.MethodName + "BatchResults"},
				Name:   "Exec",
				Params: []poet.Param{{Name: "f", Type: "func(int, error)"}},
				Stmts: []poet.Stmt{poet.RawStmt{Code: `	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
`}},
			})

		case ":batchmany":
			var batchManyBody strings.Builder
			batchManyBody.WriteString("\tdefer b.br.Close()\n")
			batchManyBody.WriteString("\tfor t := 0; t < b.tot; t++ {\n")
			if g.tctx.EmitEmptySlices {
				fmt.Fprintf(&batchManyBody, "\t\titems := []%s{}\n", q.Ret.DefineType())
			} else {
				fmt.Fprintf(&batchManyBody, "\t\tvar items []%s\n", q.Ret.DefineType())
			}
			batchManyBody.WriteString("\t\tif b.closed {\n")
			batchManyBody.WriteString("\t\t\tif f != nil {\n")
			batchManyBody.WriteString("\t\t\t\tf(t, items, ErrBatchAlreadyClosed)\n")
			batchManyBody.WriteString("\t\t\t}\n")
			batchManyBody.WriteString("\t\t\tcontinue\n")
			batchManyBody.WriteString("\t\t}\n")
			batchManyBody.WriteString("\t\terr := func() error {\n")
			batchManyBody.WriteString("\t\t\trows, err := b.br.Query()\n")
			batchManyBody.WriteString("\t\t\tif err != nil {\n")
			batchManyBody.WriteString("\t\t\t\treturn err\n")
			batchManyBody.WriteString("\t\t\t}\n")
			batchManyBody.WriteString("\t\t\tdefer rows.Close()\n")
			batchManyBody.WriteString("\t\t\tfor rows.Next() {\n")
			fmt.Fprintf(&batchManyBody, "\t\t\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
			fmt.Fprintf(&batchManyBody, "\t\t\t\tif err := rows.Scan(%s); err != nil {\n", q.Ret.Scan())
			batchManyBody.WriteString("\t\t\t\t\treturn err\n")
			batchManyBody.WriteString("\t\t\t\t}\n")
			fmt.Fprintf(&batchManyBody, "\t\t\t\titems = append(items, %s)\n", q.Ret.ReturnName())
			batchManyBody.WriteString("\t\t\t}\n")
			batchManyBody.WriteString("\t\t\treturn rows.Err()\n")
			batchManyBody.WriteString("\t\t}()\n")
			batchManyBody.WriteString("\t\tif f != nil {\n")
			batchManyBody.WriteString("\t\t\tf(t, items, err)\n")
			batchManyBody.WriteString("\t\t}\n")
			batchManyBody.WriteString("\t}\n")

			f.Decls = append(f.Decls, poet.Func{
				Recv:   &poet.Param{Name: "b", Type: "*" + q.MethodName + "BatchResults"},
				Name:   "Query",
				Params: []poet.Param{{Name: "f", Type: fmt.Sprintf("func(int, []%s, error)", q.Ret.DefineType())}},
				Stmts: []poet.Stmt{poet.RawStmt{Code: batchManyBody.String()}},
			})

		case ":batchone":
			var batchOneBody strings.Builder
			batchOneBody.WriteString("\tdefer b.br.Close()\n")
			batchOneBody.WriteString("\tfor t := 0; t < b.tot; t++ {\n")
			fmt.Fprintf(&batchOneBody, "\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
			batchOneBody.WriteString("\t\tif b.closed {\n")
			batchOneBody.WriteString("\t\t\tif f != nil {\n")
			if q.Ret.IsPointer() {
				batchOneBody.WriteString("\t\t\t\tf(t, nil, ErrBatchAlreadyClosed)\n")
			} else {
				fmt.Fprintf(&batchOneBody, "\t\t\t\tf(t, %s, ErrBatchAlreadyClosed)\n", q.Ret.Name)
			}
			batchOneBody.WriteString("\t\t\t}\n")
			batchOneBody.WriteString("\t\t\tcontinue\n")
			batchOneBody.WriteString("\t\t}\n")
			batchOneBody.WriteString("\t\trow := b.br.QueryRow()\n")
			fmt.Fprintf(&batchOneBody, "\t\terr := row.Scan(%s)\n", q.Ret.Scan())
			batchOneBody.WriteString("\t\tif f != nil {\n")
			fmt.Fprintf(&batchOneBody, "\t\t\tf(t, %s, err)\n", q.Ret.ReturnName())
			batchOneBody.WriteString("\t\t}\n")
			batchOneBody.WriteString("\t}\n")

			f.Decls = append(f.Decls, poet.Func{
				Recv:   &poet.Param{Name: "b", Type: "*" + q.MethodName + "BatchResults"},
				Name:   "QueryRow",
				Params: []poet.Param{{Name: "f", Type: fmt.Sprintf("func(int, %s, error)", q.Ret.DefineType())}},
				Stmts: []poet.Stmt{poet.RawStmt{Code: batchOneBody.String()}},
			})
		}

		// Close method
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "b", Type: "*" + q.MethodName + "BatchResults"},
			Name:    "Close",
			Results: []poet.Param{{Type: "error"}},
			Stmts: []poet.Stmt{poet.RawStmt{Code: "\tb.closed = true\n\treturn b.br.Close()\n"}},
		})
	}
}
