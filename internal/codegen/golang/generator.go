package golang

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/sqlc-dev/sqlc/internal/codegen/sdk"
	"github.com/sqlc-dev/sqlc/internal/metadata"
)

// CodeGenerator generates Go source code for sqlc.
type CodeGenerator struct {
	tctx *tmplCtx
	i    *importer
}

// NewCodeGenerator creates a new code generator.
func NewCodeGenerator(tctx *tmplCtx, i *importer) *CodeGenerator {
	return &CodeGenerator{tctx: tctx, i: i}
}

// GenerateDBFile generates the db.go file content.
func (g *CodeGenerator) GenerateDBFile() ([]byte, error) {
	var buf bytes.Buffer

	g.writeFileHeader(&buf, "")

	if g.tctx.SQLDriver.IsPGX() {
		g.writeDBCodePGX(&buf)
	} else {
		g.writeDBCodeStd(&buf)
	}

	return format.Source(buf.Bytes())
}

// GenerateModelsFile generates the models.go file content.
func (g *CodeGenerator) GenerateModelsFile() ([]byte, error) {
	var buf bytes.Buffer

	g.writeFileHeader(&buf, "")
	g.writeModelsCode(&buf)

	return format.Source(buf.Bytes())
}

// GenerateQuerierFile generates the querier.go file content.
func (g *CodeGenerator) GenerateQuerierFile() ([]byte, error) {
	var buf bytes.Buffer

	g.writeFileHeader(&buf, "")

	if g.tctx.SQLDriver.IsPGX() {
		g.writeInterfaceCodePGX(&buf)
	} else {
		g.writeInterfaceCodeStd(&buf)
	}

	return format.Source(buf.Bytes())
}

// GenerateQueryFile generates a query source file content.
func (g *CodeGenerator) GenerateQueryFile(sourceName string) ([]byte, error) {
	var buf bytes.Buffer

	g.writeFileHeader(&buf, sourceName)

	if g.tctx.SQLDriver.IsPGX() {
		g.writeQueryCodePGX(&buf, sourceName)
	} else {
		g.writeQueryCodeStd(&buf, sourceName)
	}

	return format.Source(buf.Bytes())
}

// GenerateCopyFromFile generates the copyfrom.go file content.
func (g *CodeGenerator) GenerateCopyFromFile() ([]byte, error) {
	var buf bytes.Buffer

	g.writeFileHeader(&buf, g.tctx.SourceName)

	if g.tctx.SQLDriver.IsPGX() {
		g.writeCopyFromCodePGX(&buf)
	} else if g.tctx.SQLDriver.IsGoSQLDriverMySQL() {
		g.writeCopyFromCodeMySQL(&buf)
	}

	return format.Source(buf.Bytes())
}

// GenerateBatchFile generates the batch.go file content.
func (g *CodeGenerator) GenerateBatchFile() ([]byte, error) {
	var buf bytes.Buffer

	g.writeFileHeader(&buf, g.tctx.SourceName)
	g.writeBatchCodePGX(&buf)

	return format.Source(buf.Bytes())
}

func (g *CodeGenerator) writeFileHeader(buf *bytes.Buffer, sourceComment string) {
	if g.tctx.BuildTags != "" {
		buf.WriteString("//go:build ")
		buf.WriteString(g.tctx.BuildTags)
		buf.WriteString("\n\n")
	}

	buf.WriteString("// Code generated by sqlc. DO NOT EDIT.\n")
	if !g.tctx.OmitSqlcVersion {
		buf.WriteString("// versions:\n")
		buf.WriteString("//   sqlc ")
		buf.WriteString(g.tctx.SqlcVersion)
		buf.WriteString("\n")
	}
	if sourceComment != "" {
		buf.WriteString("// source: ")
		buf.WriteString(sourceComment)
		buf.WriteString("\n")
	}

	buf.WriteString("\npackage ")
	buf.WriteString(g.tctx.Package)
	buf.WriteString("\n")

	// Write imports - use the SourceName set on tctx for looking up imports
	imports := g.i.Imports(g.tctx.SourceName)
	if len(imports[0]) > 0 || len(imports[1]) > 0 {
		buf.WriteString("\nimport (\n")
		for _, imp := range imports[0] {
			buf.WriteString("\t")
			buf.WriteString(imp.String())
			buf.WriteString("\n")
		}
		if len(imports[0]) > 0 && len(imports[1]) > 0 {
			buf.WriteString("\n")
		}
		for _, imp := range imports[1] {
			buf.WriteString("\t")
			buf.WriteString(imp.String())
			buf.WriteString("\n")
		}
		buf.WriteString(")\n")
	}
}

func (g *CodeGenerator) writeDBCodeStd(buf *bytes.Buffer) {
	// DBTX interface
	buf.WriteString(`
type DBTX interface {
	ExecContext(context.Context, string, ...interface{}) (sql.Result, error)
	PrepareContext(context.Context, string) (*sql.Stmt, error)
	QueryContext(context.Context, string, ...interface{}) (*sql.Rows, error)
	QueryRowContext(context.Context, string, ...interface{}) *sql.Row
}

`)

	// New function
	if g.tctx.EmitMethodsWithDBArgument {
		buf.WriteString("func New() *Queries {\n\treturn &Queries{}\n}\n")
	} else {
		buf.WriteString("func New(db DBTX) *Queries {\n\treturn &Queries{db: db}\n}\n")
	}

	// Prepare and Close functions for prepared queries
	if g.tctx.EmitPreparedQueries {
		buf.WriteString(`
func Prepare(ctx context.Context, db DBTX) (*Queries, error) {
	q := Queries{db: db}
	var err error
`)
		if len(g.tctx.GoQueries) == 0 {
			buf.WriteString("\t_ = err\n")
		}
		for _, query := range g.tctx.GoQueries {
			fmt.Fprintf(buf, "\tif q.%s, err = db.PrepareContext(ctx, %s); err != nil {\n", query.FieldName, query.ConstantName)
			fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"error preparing query %s: %%w\", err)\n", query.MethodName)
			buf.WriteString("\t}\n")
		}
		buf.WriteString("\treturn &q, nil\n}\n")

		buf.WriteString(`
func (q *Queries) Close() error {
	var err error
`)
		for _, query := range g.tctx.GoQueries {
			fmt.Fprintf(buf, "\tif q.%s != nil {\n", query.FieldName)
			fmt.Fprintf(buf, "\t\tif cerr := q.%s.Close(); cerr != nil {\n", query.FieldName)
			fmt.Fprintf(buf, "\t\t\terr = fmt.Errorf(\"error closing %s: %%w\", cerr)\n", query.FieldName)
			buf.WriteString("\t\t}\n\t}\n")
		}
		buf.WriteString("\treturn err\n}\n")

		// exec, query, queryRow helper functions
		buf.WriteString(`
func (q *Queries) exec(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (sql.Result, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)
	case stmt != nil:
		return stmt.ExecContext(ctx, args...)
	default:
		return q.db.ExecContext(ctx, query, args...)
	}
}

func (q *Queries) query(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) (*sql.Rows, error) {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryContext(ctx, args...)
	default:
		return q.db.QueryContext(ctx, query, args...)
	}
}

func (q *Queries) queryRow(ctx context.Context, stmt *sql.Stmt, query string, args ...interface{}) *sql.Row {
	switch {
	case stmt != nil && q.tx != nil:
		return q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)
	case stmt != nil:
		return stmt.QueryRowContext(ctx, args...)
	default:
		return q.db.QueryRowContext(ctx, query, args...)
	}
}
`)
	}

	// Queries struct
	buf.WriteString("\ntype Queries struct {\n")
	if !g.tctx.EmitMethodsWithDBArgument {
		buf.WriteString("\tdb DBTX\n")
	}
	if g.tctx.EmitPreparedQueries {
		buf.WriteString("\ttx *sql.Tx\n")
		for _, query := range g.tctx.GoQueries {
			fmt.Fprintf(buf, "\t%s *sql.Stmt\n", query.FieldName)
		}
	}
	buf.WriteString("}\n")

	// WithTx method
	if !g.tctx.EmitMethodsWithDBArgument {
		buf.WriteString("\nfunc (q *Queries) WithTx(tx *sql.Tx) *Queries {\n")
		buf.WriteString("\treturn &Queries{\n")
		buf.WriteString("\t\tdb: tx,\n")
		if g.tctx.EmitPreparedQueries {
			buf.WriteString("\t\ttx: tx,\n")
			for _, query := range g.tctx.GoQueries {
				fmt.Fprintf(buf, "\t\t%s: q.%s,\n", query.FieldName, query.FieldName)
			}
		}
		buf.WriteString("\t}\n}\n")
	}
}

func (g *CodeGenerator) writeDBCodePGX(buf *bytes.Buffer) {
	// DBTX interface
	buf.WriteString(`
type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
`)
	if g.tctx.UsesCopyFrom {
		buf.WriteString("\tCopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)\n")
	}
	if g.tctx.UsesBatch {
		buf.WriteString("\tSendBatch(context.Context, *pgx.Batch) pgx.BatchResults\n")
	}
	buf.WriteString("}\n\n")

	// New function
	if g.tctx.EmitMethodsWithDBArgument {
		buf.WriteString("func New() *Queries {\n\treturn &Queries{}\n}\n")
	} else {
		buf.WriteString("func New(db DBTX) *Queries {\n\treturn &Queries{db: db}\n}\n")
	}

	// Queries struct
	buf.WriteString("\ntype Queries struct {\n")
	if !g.tctx.EmitMethodsWithDBArgument {
		buf.WriteString("\tdb DBTX\n")
	}
	buf.WriteString("}\n")

	// WithTx method
	if !g.tctx.EmitMethodsWithDBArgument {
		buf.WriteString("\nfunc (q *Queries) WithTx(tx pgx.Tx) *Queries {\n")
		buf.WriteString("\treturn &Queries{\n")
		buf.WriteString("\t\tdb: tx,\n")
		buf.WriteString("\t}\n}\n")
	}
}

func (g *CodeGenerator) writeModelsCode(buf *bytes.Buffer) {
	// Enums
	for _, enum := range g.tctx.Enums {
		if enum.Comment != "" {
			buf.WriteString(sdk.DoubleSlashComment(enum.Comment))
			buf.WriteString("\n")
		}
		fmt.Fprintf(buf, "type %s string\n\n", enum.Name)

		buf.WriteString("const (\n")
		for _, c := range enum.Constants {
			fmt.Fprintf(buf, "\t%s %s = %q\n", c.Name, c.Type, c.Value)
		}
		buf.WriteString(")\n\n")

		// Scan method
		fmt.Fprintf(buf, "func (e *%s) Scan(src interface{}) error {\n", enum.Name)
		buf.WriteString("\tswitch s := src.(type) {\n")
		buf.WriteString("\tcase []byte:\n")
		fmt.Fprintf(buf, "\t\t*e = %s(s)\n", enum.Name)
		buf.WriteString("\tcase string:\n")
		fmt.Fprintf(buf, "\t\t*e = %s(s)\n", enum.Name)
		buf.WriteString("\tdefault:\n")
		fmt.Fprintf(buf, "\t\treturn fmt.Errorf(\"unsupported scan type for %s: %%T\", src)\n", enum.Name)
		buf.WriteString("\t}\n\treturn nil\n}\n\n")

		// Null type
		fmt.Fprintf(buf, "type Null%s struct {\n", enum.Name)
		if enum.NameTag() != "" {
			fmt.Fprintf(buf, "\t%s %s `%s`\n", enum.Name, enum.Name, enum.NameTag())
		} else {
			fmt.Fprintf(buf, "\t%s %s\n", enum.Name, enum.Name)
		}
		if enum.ValidTag() != "" {
			fmt.Fprintf(buf, "\tValid bool `%s` // Valid is true if %s is not NULL\n", enum.ValidTag(), enum.Name)
		} else {
			fmt.Fprintf(buf, "\tValid bool // Valid is true if %s is not NULL\n", enum.Name)
		}
		buf.WriteString("}\n\n")

		// Null Scan method
		buf.WriteString("// Scan implements the Scanner interface.\n")
		fmt.Fprintf(buf, "func (ns *Null%s) Scan(value interface{}) error {\n", enum.Name)
		buf.WriteString("\tif value == nil {\n")
		fmt.Fprintf(buf, "\t\tns.%s, ns.Valid = \"\", false\n", enum.Name)
		buf.WriteString("\t\treturn nil\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\tns.Valid = true\n")
		fmt.Fprintf(buf, "\treturn ns.%s.Scan(value)\n", enum.Name)
		buf.WriteString("}\n\n")

		// Null Value method
		buf.WriteString("// Value implements the driver Valuer interface.\n")
		fmt.Fprintf(buf, "func (ns Null%s) Value() (driver.Value, error) {\n", enum.Name)
		buf.WriteString("\tif !ns.Valid {\n")
		buf.WriteString("\t\treturn nil, nil\n")
		buf.WriteString("\t}\n")
		fmt.Fprintf(buf, "\treturn string(ns.%s), nil\n", enum.Name)
		buf.WriteString("}\n")

		// Valid method
		if g.tctx.EmitEnumValidMethod {
			fmt.Fprintf(buf, "\nfunc (e %s) Valid() bool {\n", enum.Name)
			buf.WriteString("\tswitch e {\n")
			buf.WriteString("\tcase ")
			for i, c := range enum.Constants {
				if i > 0 {
					buf.WriteString(",\n\t\t")
				}
				buf.WriteString(c.Name)
			}
			buf.WriteString(":\n")
			buf.WriteString("\t\treturn true\n")
			buf.WriteString("\t}\n")
			buf.WriteString("\treturn false\n")
			buf.WriteString("}\n")
		}

		// AllValues method
		if g.tctx.EmitAllEnumValues {
			fmt.Fprintf(buf, "\nfunc All%sValues() []%s {\n", enum.Name, enum.Name)
			fmt.Fprintf(buf, "\treturn []%s{\n", enum.Name)
			for _, c := range enum.Constants {
				fmt.Fprintf(buf, "\t\t%s,\n", c.Name)
			}
			buf.WriteString("\t}\n")
			buf.WriteString("}\n")
		}
		buf.WriteString("\n")
	}

	// Structs
	for _, s := range g.tctx.Structs {
		if s.Comment != "" {
			buf.WriteString(sdk.DoubleSlashComment(s.Comment))
			buf.WriteString("\n")
		}
		fmt.Fprintf(buf, "type %s struct {\n", s.Name)
		for _, f := range s.Fields {
			if f.Comment != "" {
				buf.WriteString(sdk.DoubleSlashComment(f.Comment))
				buf.WriteString("\n")
			}
			if f.Tag() != "" {
				fmt.Fprintf(buf, "\t%s %s `%s`\n", f.Name, f.Type, f.Tag())
			} else {
				fmt.Fprintf(buf, "\t%s %s\n", f.Name, f.Type)
			}
		}
		buf.WriteString("}\n\n")
	}
}

func (g *CodeGenerator) writeInterfaceCodeStd(buf *bytes.Buffer) {
	buf.WriteString("\ntype Querier interface {\n")
	for _, q := range g.tctx.GoQueries {
		g.writeInterfaceMethod(buf, q, false)
	}
	buf.WriteString("}\n\n")
	buf.WriteString("var _ Querier = (*Queries)(nil)\n")
}

func (g *CodeGenerator) writeInterfaceCodePGX(buf *bytes.Buffer) {
	buf.WriteString("\ntype Querier interface {\n")
	for _, q := range g.tctx.GoQueries {
		g.writeInterfaceMethod(buf, q, true)
	}
	buf.WriteString("}\n\n")
	buf.WriteString("var _ Querier = (*Queries)(nil)\n")
}

func (g *CodeGenerator) writeInterfaceMethod(buf *bytes.Buffer, q Query, isPGX bool) {
	for _, comment := range q.Comments {
		fmt.Fprintf(buf, "//%s\n", comment)
	}

	var params, returnType string

	switch q.Cmd {
	case ":one":
		params = q.Arg.Pair()
		returnType = fmt.Sprintf("(%s, error)", q.Ret.DefineType())
	case ":many":
		params = q.Arg.Pair()
		returnType = fmt.Sprintf("([]%s, error)", q.Ret.DefineType())
	case ":exec":
		params = q.Arg.Pair()
		returnType = "error"
	case ":execrows":
		params = q.Arg.Pair()
		returnType = "(int64, error)"
	case ":execlastid":
		params = q.Arg.Pair()
		returnType = "(int64, error)"
	case ":execresult":
		params = q.Arg.Pair()
		if isPGX {
			returnType = "(pgconn.CommandTag, error)"
		} else {
			returnType = "(sql.Result, error)"
		}
	case ":copyfrom":
		params = q.Arg.SlicePair()
		returnType = "(int64, error)"
	case ":batchexec", ":batchmany", ":batchone":
		params = q.Arg.SlicePair()
		returnType = fmt.Sprintf("*%sBatchResults", q.MethodName)
	default:
		return
	}

	if g.tctx.EmitMethodsWithDBArgument {
		if params != "" {
			params = "db DBTX, " + params
		} else {
			params = "db DBTX"
		}
	}

	fmt.Fprintf(buf, "\t%s(ctx context.Context, %s) %s\n", q.MethodName, params, returnType)
}

func (g *CodeGenerator) writeQueryCodeStd(buf *bytes.Buffer, sourceName string) {
	for _, q := range g.tctx.GoQueries {
		if q.SourceName != sourceName {
			continue
		}
		g.writeQueryStd(buf, q)
	}
}

func (g *CodeGenerator) writeQueryStd(buf *bytes.Buffer, q Query) {
	// SQL constant
	fmt.Fprintf(buf, "\nconst %s = `-- name: %s %s\n%s\n`\n", q.ConstantName, q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL))

	// Arg struct if needed
	if q.Arg.EmitStruct() {
		fmt.Fprintf(buf, "\ntype %s struct {\n", q.Arg.Type())
		for _, f := range q.Arg.UniqueFields() {
			if f.Tag() != "" {
				fmt.Fprintf(buf, "\t%s %s `%s`\n", f.Name, f.Type, f.Tag())
			} else {
				fmt.Fprintf(buf, "\t%s %s\n", f.Name, f.Type)
			}
		}
		buf.WriteString("}\n")
	}

	// Ret struct if needed
	if q.Ret.EmitStruct() {
		fmt.Fprintf(buf, "\ntype %s struct {\n", q.Ret.Type())
		for _, f := range q.Ret.Struct.Fields {
			if f.Tag() != "" {
				fmt.Fprintf(buf, "\t%s %s `%s`\n", f.Name, f.Type, f.Tag())
			} else {
				fmt.Fprintf(buf, "\t%s %s\n", f.Name, f.Type)
			}
		}
		buf.WriteString("}\n")
	}

	// Method
	switch q.Cmd {
	case ":one":
		g.writeQueryOneStd(buf, q)
	case ":many":
		g.writeQueryManyStd(buf, q)
	case ":exec":
		g.writeQueryExecStd(buf, q)
	case ":execrows":
		g.writeQueryExecRowsStd(buf, q)
	case ":execlastid":
		g.writeQueryExecLastIDStd(buf, q)
	case ":execresult":
		g.writeQueryExecResultStd(buf, q)
	}
}

func (g *CodeGenerator) writeQueryComments(buf *bytes.Buffer, q Query) {
	for _, comment := range q.Comments {
		fmt.Fprintf(buf, "//%s\n", comment)
	}
}

func (g *CodeGenerator) writeQueryOneStd(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)
	fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s%s) (%s, error) {\n",
		q.MethodName, g.tctx.codegenDbarg(), q.Arg.Pair(), q.Ret.DefineType())

	g.writeQueryExecStdCall(buf, q, "row :=")

	if q.Arg.Pair() != q.Ret.Pair() || q.Arg.DefineType() != q.Ret.DefineType() {
		fmt.Fprintf(buf, "\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	}

	fmt.Fprintf(buf, "\terr := row.Scan(%s)\n", q.Ret.Scan())

	if g.tctx.WrapErrors {
		buf.WriteString("\tif err != nil {\n")
		fmt.Fprintf(buf, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		buf.WriteString("\t}\n")
	}

	fmt.Fprintf(buf, "\treturn %s, err\n", q.Ret.ReturnName())
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryManyStd(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)
	fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s%s) ([]%s, error) {\n",
		q.MethodName, g.tctx.codegenDbarg(), q.Arg.Pair(), q.Ret.DefineType())

	g.writeQueryExecStdCall(buf, q, "rows, err :=")

	buf.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\treturn nil, err\n")
	}
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer rows.Close()\n")

	if g.tctx.EmitEmptySlices {
		fmt.Fprintf(buf, "\titems := []%s{}\n", q.Ret.DefineType())
	} else {
		fmt.Fprintf(buf, "\tvar items []%s\n", q.Ret.DefineType())
	}

	buf.WriteString("\tfor rows.Next() {\n")
	fmt.Fprintf(buf, "\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	fmt.Fprintf(buf, "\t\tif err := rows.Scan(%s); err != nil {\n", q.Ret.Scan())
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\t\treturn nil, err\n")
	}
	buf.WriteString("\t\t}\n")
	fmt.Fprintf(buf, "\t\titems = append(items, %s)\n", q.Ret.ReturnName())
	buf.WriteString("\t}\n")

	buf.WriteString("\tif err := rows.Close(); err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\treturn nil, err\n")
	}
	buf.WriteString("\t}\n")

	buf.WriteString("\tif err := rows.Err(); err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\treturn nil, err\n")
	}
	buf.WriteString("\t}\n")

	buf.WriteString("\treturn items, nil\n")
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryExecStd(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)
	fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s%s) error {\n",
		q.MethodName, g.tctx.codegenDbarg(), q.Arg.Pair())

	g.writeQueryExecStdCall(buf, q, "_, err :=")

	if g.tctx.WrapErrors {
		buf.WriteString("\tif err != nil {\n")
		fmt.Fprintf(buf, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		buf.WriteString("\t}\n")
	}
	buf.WriteString("\treturn err\n")
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryExecRowsStd(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)
	fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s%s) (int64, error) {\n",
		q.MethodName, g.tctx.codegenDbarg(), q.Arg.Pair())

	g.writeQueryExecStdCall(buf, q, "result, err :=")

	buf.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\treturn 0, err\n")
	}
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn result.RowsAffected()\n")
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryExecLastIDStd(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)
	fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s%s) (int64, error) {\n",
		q.MethodName, g.tctx.codegenDbarg(), q.Arg.Pair())

	g.writeQueryExecStdCall(buf, q, "result, err :=")

	buf.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\treturn 0, err\n")
	}
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn result.LastInsertId()\n")
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryExecResultStd(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)
	fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s%s) (sql.Result, error) {\n",
		q.MethodName, g.tctx.codegenDbarg(), q.Arg.Pair())

	if g.tctx.WrapErrors {
		g.writeQueryExecStdCall(buf, q, "result, err :=")
		buf.WriteString("\tif err != nil {\n")
		fmt.Fprintf(buf, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn result, err\n")
	} else {
		g.writeQueryExecStdCall(buf, q, "return")
	}
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryExecStdCall(buf *bytes.Buffer, q Query, retval string) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	if q.Arg.HasSqlcSlices() {
		g.writeQuerySliceExec(buf, q, retval, db, false)
		return
	}

	var method string
	switch q.Cmd {
	case ":one":
		if g.tctx.EmitPreparedQueries {
			method = "q.queryRow"
		} else {
			method = db + ".QueryRowContext"
		}
	case ":many":
		if g.tctx.EmitPreparedQueries {
			method = "q.query"
		} else {
			method = db + ".QueryContext"
		}
	default:
		if g.tctx.EmitPreparedQueries {
			method = "q.exec"
		} else {
			method = db + ".ExecContext"
		}
	}

	if g.tctx.EmitPreparedQueries {
		params := q.Arg.Params()
		if params != "" {
			params = ", " + params
		}
		fmt.Fprintf(buf, "\t%s %s(ctx, q.%s, %s%s)\n", retval, method, q.FieldName, q.ConstantName, params)
	} else {
		params := q.Arg.Params()
		if params != "" {
			params = ", " + params
		}
		fmt.Fprintf(buf, "\t%s %s(ctx, %s%s)\n", retval, method, q.ConstantName, params)
	}
}

func (g *CodeGenerator) writeQuerySliceExec(buf *bytes.Buffer, q Query, retval, db string, isPGX bool) {
	buf.WriteString("\tquery := " + q.ConstantName + "\n")
	buf.WriteString("\tvar queryParams []interface{}\n")

	if q.Arg.Struct != nil {
		for _, f := range q.Arg.Struct.Fields {
			varName := q.Arg.VariableForField(f)
			if f.HasSqlcSlice() {
				fmt.Fprintf(buf, "\tif len(%s) > 0 {\n", varName)
				fmt.Fprintf(buf, "\t\tfor _, v := range %s {\n", varName)
				buf.WriteString("\t\t\tqueryParams = append(queryParams, v)\n")
				buf.WriteString("\t\t}\n")
				fmt.Fprintf(buf, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , strings.Repeat(\",?\", len(%s))[1:], 1)\n", f.Column.Name, varName)
				buf.WriteString("\t} else {\n")
				fmt.Fprintf(buf, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , \"NULL\", 1)\n", f.Column.Name)
				buf.WriteString("\t}\n")
			} else {
				fmt.Fprintf(buf, "\tqueryParams = append(queryParams, %s)\n", varName)
			}
		}
	} else {
		argName := q.Arg.Name
		colName := q.Arg.Column.Name
		fmt.Fprintf(buf, "\tif len(%s) > 0 {\n", argName)
		fmt.Fprintf(buf, "\t\tfor _, v := range %s {\n", argName)
		buf.WriteString("\t\t\tqueryParams = append(queryParams, v)\n")
		buf.WriteString("\t\t}\n")
		fmt.Fprintf(buf, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , strings.Repeat(\",?\", len(%s))[1:], 1)\n", colName, argName)
		buf.WriteString("\t} else {\n")
		fmt.Fprintf(buf, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , \"NULL\", 1)\n", colName)
		buf.WriteString("\t}\n")
	}

	var method string
	switch q.Cmd {
	case ":one":
		if g.tctx.EmitPreparedQueries {
			method = "q.queryRow"
		} else {
			method = db + ".QueryRowContext"
		}
	case ":many":
		if g.tctx.EmitPreparedQueries {
			method = "q.query"
		} else {
			method = db + ".QueryContext"
		}
	default:
		if g.tctx.EmitPreparedQueries {
			method = "q.exec"
		} else {
			method = db + ".ExecContext"
		}
	}

	if g.tctx.EmitPreparedQueries {
		fmt.Fprintf(buf, "\t%s %s(ctx, nil, query, queryParams...)\n", retval, method)
	} else {
		fmt.Fprintf(buf, "\t%s %s(ctx, query, queryParams...)\n", retval, method)
	}
}

func (g *CodeGenerator) writeQueryCodePGX(buf *bytes.Buffer, sourceName string) {
	for _, q := range g.tctx.GoQueries {
		if q.SourceName != sourceName {
			continue
		}
		if strings.HasPrefix(q.Cmd, ":batch") {
			// Batch queries are fully handled in batch.go
			continue
		}
		if q.Cmd == metadata.CmdCopyFrom {
			// For copyfrom, only emit the struct definition (implementation is in copyfrom.go)
			if q.Arg.EmitStruct() {
				fmt.Fprintf(buf, "\ntype %s struct {\n", q.Arg.Type())
				for _, f := range q.Arg.Struct.Fields {
					if f.Tag() != "" {
						fmt.Fprintf(buf, "\t%s %s `%s`\n", f.Name, f.Type, f.Tag())
					} else {
						fmt.Fprintf(buf, "\t%s %s\n", f.Name, f.Type)
					}
				}
				buf.WriteString("}\n")
			}
			continue
		}
		g.writeQueryPGX(buf, q)
	}
}

func (g *CodeGenerator) writeQueryPGX(buf *bytes.Buffer, q Query) {
	// SQL constant
	fmt.Fprintf(buf, "\nconst %s = `-- name: %s %s\n%s\n`\n", q.ConstantName, q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL))

	// Arg struct if needed
	if q.Arg.EmitStruct() {
		fmt.Fprintf(buf, "\ntype %s struct {\n", q.Arg.Type())
		for _, f := range q.Arg.Struct.Fields {
			if f.Tag() != "" {
				fmt.Fprintf(buf, "\t%s %s `%s`\n", f.Name, f.Type, f.Tag())
			} else {
				fmt.Fprintf(buf, "\t%s %s\n", f.Name, f.Type)
			}
		}
		buf.WriteString("}\n")
	}

	// Ret struct if needed
	if q.Ret.EmitStruct() {
		fmt.Fprintf(buf, "\ntype %s struct {\n", q.Ret.Type())
		for _, f := range q.Ret.Struct.Fields {
			if f.Tag() != "" {
				fmt.Fprintf(buf, "\t%s %s `%s`\n", f.Name, f.Type, f.Tag())
			} else {
				fmt.Fprintf(buf, "\t%s %s\n", f.Name, f.Type)
			}
		}
		buf.WriteString("}\n")
	}

	// Method
	switch q.Cmd {
	case ":one":
		g.writeQueryOnePGX(buf, q)
	case ":many":
		g.writeQueryManyPGX(buf, q)
	case ":exec":
		g.writeQueryExecPGX(buf, q)
	case ":execrows":
		g.writeQueryExecRowsPGX(buf, q)
	case ":execresult":
		g.writeQueryExecResultPGX(buf, q)
	}
}

func (g *CodeGenerator) writeQueryOnePGX(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)

	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, db DBTX, %s) (%s, error) {\n",
			q.MethodName, q.Arg.Pair(), q.Ret.DefineType())
	} else {
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s) (%s, error) {\n",
			q.MethodName, q.Arg.Pair(), q.Ret.DefineType())
	}

	params := q.Arg.Params()
	if params != "" {
		params = ", " + params
	}
	fmt.Fprintf(buf, "\trow := %s.QueryRow(ctx, %s%s)\n", db, q.ConstantName, params)

	if q.Arg.Pair() != q.Ret.Pair() || q.Arg.DefineType() != q.Ret.DefineType() {
		fmt.Fprintf(buf, "\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	}

	fmt.Fprintf(buf, "\terr := row.Scan(%s)\n", q.Ret.Scan())

	if g.tctx.WrapErrors {
		buf.WriteString("\tif err != nil {\n")
		fmt.Fprintf(buf, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		buf.WriteString("\t}\n")
	}

	fmt.Fprintf(buf, "\treturn %s, err\n", q.Ret.ReturnName())
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryManyPGX(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)

	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, db DBTX, %s) ([]%s, error) {\n",
			q.MethodName, q.Arg.Pair(), q.Ret.DefineType())
	} else {
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s) ([]%s, error) {\n",
			q.MethodName, q.Arg.Pair(), q.Ret.DefineType())
	}

	params := q.Arg.Params()
	if params != "" {
		params = ", " + params
	}
	fmt.Fprintf(buf, "\trows, err := %s.Query(ctx, %s%s)\n", db, q.ConstantName, params)

	buf.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\treturn nil, err\n")
	}
	buf.WriteString("\t}\n")
	buf.WriteString("\tdefer rows.Close()\n")

	if g.tctx.EmitEmptySlices {
		fmt.Fprintf(buf, "\titems := []%s{}\n", q.Ret.DefineType())
	} else {
		fmt.Fprintf(buf, "\tvar items []%s\n", q.Ret.DefineType())
	}

	buf.WriteString("\tfor rows.Next() {\n")
	fmt.Fprintf(buf, "\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	fmt.Fprintf(buf, "\t\tif err := rows.Scan(%s); err != nil {\n", q.Ret.Scan())
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\t\treturn nil, err\n")
	}
	buf.WriteString("\t\t}\n")
	fmt.Fprintf(buf, "\t\titems = append(items, %s)\n", q.Ret.ReturnName())
	buf.WriteString("\t}\n")

	buf.WriteString("\tif err := rows.Err(); err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\treturn nil, err\n")
	}
	buf.WriteString("\t}\n")

	buf.WriteString("\treturn items, nil\n")
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryExecPGX(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)

	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, db DBTX, %s) error {\n",
			q.MethodName, q.Arg.Pair())
	} else {
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s) error {\n",
			q.MethodName, q.Arg.Pair())
	}

	params := q.Arg.Params()
	if params != "" {
		params = ", " + params
	}
	fmt.Fprintf(buf, "\t_, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, params)

	if g.tctx.WrapErrors {
		buf.WriteString("\tif err != nil {\n")
		fmt.Fprintf(buf, "\t\treturn fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn nil\n")
	} else {
		buf.WriteString("\treturn err\n")
	}
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryExecRowsPGX(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)

	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, db DBTX, %s) (int64, error) {\n",
			q.MethodName, q.Arg.Pair())
	} else {
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s) (int64, error) {\n",
			q.MethodName, q.Arg.Pair())
	}

	params := q.Arg.Params()
	if params != "" {
		params = ", " + params
	}
	fmt.Fprintf(buf, "\tresult, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, params)

	buf.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		buf.WriteString("\t\treturn 0, err\n")
	}
	buf.WriteString("\t}\n")
	buf.WriteString("\treturn result.RowsAffected(), nil\n")
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeQueryExecResultPGX(buf *bytes.Buffer, q Query) {
	g.writeQueryComments(buf, q)

	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, db DBTX, %s) (pgconn.CommandTag, error) {\n",
			q.MethodName, q.Arg.Pair())
	} else {
		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s) (pgconn.CommandTag, error) {\n",
			q.MethodName, q.Arg.Pair())
	}

	params := q.Arg.Params()
	if params != "" {
		params = ", " + params
	}

	if g.tctx.WrapErrors {
		fmt.Fprintf(buf, "\tresult, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, params)
		buf.WriteString("\tif err != nil {\n")
		fmt.Fprintf(buf, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn result, err\n")
	} else {
		fmt.Fprintf(buf, "\treturn %s.Exec(ctx, %s%s)\n", db, q.ConstantName, params)
	}
	buf.WriteString("}\n")
}

func (g *CodeGenerator) writeCopyFromCodePGX(buf *bytes.Buffer) {
	for _, q := range g.tctx.GoQueries {
		if q.Cmd != metadata.CmdCopyFrom {
			continue
		}

		// Iterator struct
		fmt.Fprintf(buf, "\n// iteratorFor%s implements pgx.CopyFromSource.\n", q.MethodName)
		fmt.Fprintf(buf, "type iteratorFor%s struct {\n", q.MethodName)
		fmt.Fprintf(buf, "\trows                 []%s\n", q.Arg.DefineType())
		buf.WriteString("\tskippedFirstNextCall bool\n")
		buf.WriteString("}\n\n")

		// Next method
		fmt.Fprintf(buf, "func (r *iteratorFor%s) Next() bool {\n", q.MethodName)
		buf.WriteString("\tif len(r.rows) == 0 {\n")
		buf.WriteString("\t\treturn false\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\tif !r.skippedFirstNextCall {\n")
		buf.WriteString("\t\tr.skippedFirstNextCall = true\n")
		buf.WriteString("\t\treturn true\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\tr.rows = r.rows[1:]\n")
		buf.WriteString("\treturn len(r.rows) > 0\n")
		buf.WriteString("}\n\n")

		// Values method
		fmt.Fprintf(buf, "func (r iteratorFor%s) Values() ([]interface{}, error) {\n", q.MethodName)
		buf.WriteString("\treturn []interface{}{\n")
		if q.Arg.Struct != nil {
			for _, f := range q.Arg.Struct.Fields {
				fmt.Fprintf(buf, "\t\tr.rows[0].%s,\n", f.Name)
			}
		} else {
			buf.WriteString("\t\tr.rows[0],\n")
		}
		buf.WriteString("\t}, nil\n")
		buf.WriteString("}\n\n")

		// Err method
		fmt.Fprintf(buf, "func (r iteratorFor%s) Err() error {\n", q.MethodName)
		buf.WriteString("\treturn nil\n")
		buf.WriteString("}\n\n")

		// Main method
		g.writeQueryComments(buf, q)
		db := "q.db"
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, db DBTX, %s) (int64, error) {\n",
				q.MethodName, q.Arg.SlicePair())
		} else {
			fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s) (int64, error) {\n",
				q.MethodName, q.Arg.SlicePair())
		}
		fmt.Fprintf(buf, "\treturn %s.CopyFrom(ctx, %s, %s, &iteratorFor%s{rows: %s})\n",
			db, q.TableIdentifierAsGoSlice(), q.Arg.ColumnNamesAsGoSlice(), q.MethodName, q.Arg.Name)
		buf.WriteString("}\n")
	}
}

func (g *CodeGenerator) writeCopyFromCodeMySQL(buf *bytes.Buffer) {
	for _, q := range g.tctx.GoQueries {
		if q.Cmd != metadata.CmdCopyFrom {
			continue
		}

		// Reader handler sequence
		fmt.Fprintf(buf, "\nvar readerHandlerSequenceFor%s uint32 = 1\n\n", q.MethodName)

		// Convert rows function
		fmt.Fprintf(buf, "func convertRowsFor%s(w *io.PipeWriter, %s) {\n", q.MethodName, q.Arg.SlicePair())
		fmt.Fprintf(buf, "\te := mysqltsv.NewEncoder(w, %d, nil)\n", len(q.Arg.CopyFromMySQLFields()))
		fmt.Fprintf(buf, "\tfor _, row := range %s {\n", q.Arg.Name)

		for _, f := range q.Arg.CopyFromMySQLFields() {
			accessor := "row"
			if q.Arg.Struct != nil {
				accessor = "row." + f.Name
			}
			switch f.Type {
			case "string":
				fmt.Fprintf(buf, "\t\te.AppendString(%s)\n", accessor)
			case "[]byte", "json.RawMessage":
				fmt.Fprintf(buf, "\t\te.AppendBytes(%s)\n", accessor)
			default:
				fmt.Fprintf(buf, "\t\te.AppendValue(%s)\n", accessor)
			}
		}

		buf.WriteString("\t}\n")
		buf.WriteString("\tw.CloseWithError(e.Close())\n")
		buf.WriteString("}\n\n")

		// Main method
		g.writeQueryComments(buf, q)
		fmt.Fprintf(buf, "// %s uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.\n", q.MethodName)
		buf.WriteString("//\n")
		buf.WriteString("// Errors and duplicate keys are treated as warnings and insertion will\n")
		buf.WriteString("// continue, even without an error for some cases.  Use this in a transaction\n")
		buf.WriteString("// and use SHOW WARNINGS to check for any problems and roll back if you want to.\n")
		buf.WriteString("//\n")
		buf.WriteString("// Check the documentation for more information:\n")
		buf.WriteString("// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling\n")

		db := "q.db"
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, db DBTX, %s) (int64, error) {\n",
				q.MethodName, q.Arg.SlicePair())
		} else {
			fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s) (int64, error) {\n",
				q.MethodName, q.Arg.SlicePair())
		}

		buf.WriteString("\tpr, pw := io.Pipe()\n")
		buf.WriteString("\tdefer pr.Close()\n")
		fmt.Fprintf(buf, "\trh := fmt.Sprintf(\"%s_%%d\", atomic.AddUint32(&readerHandlerSequenceFor%s, 1))\n", q.MethodName, q.MethodName)
		buf.WriteString("\tmysql.RegisterReaderHandler(rh, func() io.Reader { return pr })\n")
		buf.WriteString("\tdefer mysql.DeregisterReaderHandler(rh)\n")
		fmt.Fprintf(buf, "\tgo convertRowsFor%s(pw, %s)\n", q.MethodName, q.Arg.Name)

		// Build column names
		var colNames []string
		for _, name := range q.Arg.ColumnNames() {
			colNames = append(colNames, name)
		}
		colList := strings.Join(colNames, ", ")

		buf.WriteString("\t// The string interpolation is necessary because LOAD DATA INFILE requires\n")
		buf.WriteString("\t// the file name to be given as a literal string.\n")
		fmt.Fprintf(buf, "\tresult, err := %s.ExecContext(ctx, fmt.Sprintf(\"LOAD DATA LOCAL INFILE '%%s' INTO TABLE %s %%s (%s)\", \"Reader::\"+rh, mysqltsv.Escaping))\n",
			db, q.TableIdentifierForMySQL(), colList)
		buf.WriteString("\tif err != nil {\n")
		buf.WriteString("\t\treturn 0, err\n")
		buf.WriteString("\t}\n")
		buf.WriteString("\treturn result.RowsAffected()\n")
		buf.WriteString("}\n")
	}
}

func (g *CodeGenerator) writeBatchCodePGX(buf *bytes.Buffer) {
	// Error variable
	buf.WriteString("\nvar (\n")
	buf.WriteString("\tErrBatchAlreadyClosed = errors.New(\"batch already closed\")\n")
	buf.WriteString(")\n")

	for _, q := range g.tctx.GoQueries {
		if !strings.HasPrefix(q.Cmd, ":batch") {
			continue
		}

		// SQL constant
		fmt.Fprintf(buf, "\nconst %s = `-- name: %s %s\n%s\n`\n", q.ConstantName, q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL))

		// BatchResults struct
		fmt.Fprintf(buf, "\ntype %sBatchResults struct {\n", q.MethodName)
		buf.WriteString("\tbr     pgx.BatchResults\n")
		buf.WriteString("\ttot    int\n")
		buf.WriteString("\tclosed bool\n")
		buf.WriteString("}\n")

		// Arg struct if needed
		if q.Arg.Struct != nil {
			fmt.Fprintf(buf, "\ntype %s struct {\n", q.Arg.Type())
			for _, f := range q.Arg.Struct.Fields {
				if f.Tag() != "" {
					fmt.Fprintf(buf, "\t%s %s `%s`\n", f.Name, f.Type, f.Tag())
				} else {
					fmt.Fprintf(buf, "\t%s %s\n", f.Name, f.Type)
				}
			}
			buf.WriteString("}\n")
		}

		// Ret struct if needed
		if q.Ret.EmitStruct() {
			fmt.Fprintf(buf, "\ntype %s struct {\n", q.Ret.Type())
			for _, f := range q.Ret.Struct.Fields {
				if f.Tag() != "" {
					fmt.Fprintf(buf, "\t%s %s `%s`\n", f.Name, f.Type, f.Tag())
				} else {
					fmt.Fprintf(buf, "\t%s %s\n", f.Name, f.Type)
				}
			}
			buf.WriteString("}\n")
		}

		// Main batch method
		g.writeQueryComments(buf, q)

		db := "q.db"
		dbParam := ""
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			dbParam = "db DBTX, "
		}

		fmt.Fprintf(buf, "func (q *Queries) %s(ctx context.Context, %s%s) *%sBatchResults {\n",
			q.MethodName, dbParam, q.Arg.SlicePair(), q.MethodName)
		buf.WriteString("\tbatch := &pgx.Batch{}\n")
		fmt.Fprintf(buf, "\tfor _, a := range %s {\n", q.Arg.Name)
		buf.WriteString("\t\tvals := []interface{}{\n")
		if q.Arg.Struct != nil {
			for _, f := range q.Arg.Struct.Fields {
				fmt.Fprintf(buf, "\t\t\ta.%s,\n", f.Name)
			}
		} else {
			buf.WriteString("\t\t\ta,\n")
		}
		buf.WriteString("\t\t}\n")
		fmt.Fprintf(buf, "\t\tbatch.Queue(%s, vals...)\n", q.ConstantName)
		buf.WriteString("\t}\n")
		fmt.Fprintf(buf, "\tbr := %s.SendBatch(ctx, batch)\n", db)
		fmt.Fprintf(buf, "\treturn &%sBatchResults{br, len(%s), false}\n", q.MethodName, q.Arg.Name)
		buf.WriteString("}\n")

		// Result method based on command type
		switch q.Cmd {
		case ":batchexec":
			fmt.Fprintf(buf, "\nfunc (b *%sBatchResults) Exec(f func(int, error)) {\n", q.MethodName)
			buf.WriteString("\tdefer b.br.Close()\n")
			buf.WriteString("\tfor t := 0; t < b.tot; t++ {\n")
			buf.WriteString("\t\tif b.closed {\n")
			buf.WriteString("\t\t\tif f != nil {\n")
			buf.WriteString("\t\t\t\tf(t, ErrBatchAlreadyClosed)\n")
			buf.WriteString("\t\t\t}\n")
			buf.WriteString("\t\t\tcontinue\n")
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t\t_, err := b.br.Exec()\n")
			buf.WriteString("\t\tif f != nil {\n")
			buf.WriteString("\t\t\tf(t, err)\n")
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}\n")
			buf.WriteString("}\n")

		case ":batchmany":
			fmt.Fprintf(buf, "\nfunc (b *%sBatchResults) Query(f func(int, []%s, error)) {\n", q.MethodName, q.Ret.DefineType())
			buf.WriteString("\tdefer b.br.Close()\n")
			buf.WriteString("\tfor t := 0; t < b.tot; t++ {\n")
			if g.tctx.EmitEmptySlices {
				fmt.Fprintf(buf, "\t\titems := []%s{}\n", q.Ret.DefineType())
			} else {
				fmt.Fprintf(buf, "\t\tvar items []%s\n", q.Ret.DefineType())
			}
			buf.WriteString("\t\tif b.closed {\n")
			buf.WriteString("\t\t\tif f != nil {\n")
			buf.WriteString("\t\t\t\tf(t, items, ErrBatchAlreadyClosed)\n")
			buf.WriteString("\t\t\t}\n")
			buf.WriteString("\t\t\tcontinue\n")
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t\terr := func() error {\n")
			buf.WriteString("\t\t\trows, err := b.br.Query()\n")
			buf.WriteString("\t\t\tif err != nil {\n")
			buf.WriteString("\t\t\t\treturn err\n")
			buf.WriteString("\t\t\t}\n")
			buf.WriteString("\t\t\tdefer rows.Close()\n")
			buf.WriteString("\t\t\tfor rows.Next() {\n")
			fmt.Fprintf(buf, "\t\t\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
			fmt.Fprintf(buf, "\t\t\t\tif err := rows.Scan(%s); err != nil {\n", q.Ret.Scan())
			buf.WriteString("\t\t\t\t\treturn err\n")
			buf.WriteString("\t\t\t\t}\n")
			fmt.Fprintf(buf, "\t\t\t\titems = append(items, %s)\n", q.Ret.ReturnName())
			buf.WriteString("\t\t\t}\n")
			buf.WriteString("\t\t\treturn rows.Err()\n")
			buf.WriteString("\t\t}()\n")
			buf.WriteString("\t\tif f != nil {\n")
			buf.WriteString("\t\t\tf(t, items, err)\n")
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}\n")
			buf.WriteString("}\n")

		case ":batchone":
			fmt.Fprintf(buf, "\nfunc (b *%sBatchResults) QueryRow(f func(int, %s, error)) {\n", q.MethodName, q.Ret.DefineType())
			buf.WriteString("\tdefer b.br.Close()\n")
			buf.WriteString("\tfor t := 0; t < b.tot; t++ {\n")
			fmt.Fprintf(buf, "\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
			buf.WriteString("\t\tif b.closed {\n")
			buf.WriteString("\t\t\tif f != nil {\n")
			if q.Ret.IsPointer() {
				buf.WriteString("\t\t\t\tf(t, nil, ErrBatchAlreadyClosed)\n")
			} else {
				fmt.Fprintf(buf, "\t\t\t\tf(t, %s, ErrBatchAlreadyClosed)\n", q.Ret.Name)
			}
			buf.WriteString("\t\t\t}\n")
			buf.WriteString("\t\t\tcontinue\n")
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t\trow := b.br.QueryRow()\n")
			fmt.Fprintf(buf, "\t\terr := row.Scan(%s)\n", q.Ret.Scan())
			buf.WriteString("\t\tif f != nil {\n")
			fmt.Fprintf(buf, "\t\t\tf(t, %s, err)\n", q.Ret.ReturnName())
			buf.WriteString("\t\t}\n")
			buf.WriteString("\t}\n")
			buf.WriteString("}\n")
		}

		// Close method
		fmt.Fprintf(buf, "\nfunc (b *%sBatchResults) Close() error {\n", q.MethodName)
		buf.WriteString("\tb.closed = true\n")
		buf.WriteString("\treturn b.br.Close()\n")
		buf.WriteString("}\n")
	}
}
