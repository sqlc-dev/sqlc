package golang

import (
	"fmt"
	"strings"

	"github.com/sqlc-dev/sqlc/internal/codegen/sdk"
	"github.com/sqlc-dev/sqlc/internal/metadata"
	"github.com/sqlc-dev/sqlc/internal/poet"
)

// CodeGenerator generates Go source code for sqlc.
type CodeGenerator struct {
	tctx *tmplCtx
	i    *importer
}

// NewCodeGenerator creates a new code generator.
func NewCodeGenerator(tctx *tmplCtx, i *importer) *CodeGenerator {
	return &CodeGenerator{tctx: tctx, i: i}
}

// GenerateDBFile generates the db.go file content.
func (g *CodeGenerator) GenerateDBFile() ([]byte, error) {
	f := g.newFile("")
	if g.tctx.SQLDriver.IsPGX() {
		g.addDBCodePGX(f)
	} else {
		g.addDBCodeStd(f)
	}
	return poet.Render(f)
}

// GenerateModelsFile generates the models.go file content.
func (g *CodeGenerator) GenerateModelsFile() ([]byte, error) {
	f := g.newFile("")
	g.addModelsCode(f)
	return poet.Render(f)
}

// GenerateQuerierFile generates the querier.go file content.
func (g *CodeGenerator) GenerateQuerierFile() ([]byte, error) {
	f := g.newFile("")
	if g.tctx.SQLDriver.IsPGX() {
		g.addInterfaceCodePGX(f)
	} else {
		g.addInterfaceCodeStd(f)
	}
	return poet.Render(f)
}

// GenerateQueryFile generates a query source file content.
func (g *CodeGenerator) GenerateQueryFile(sourceName string) ([]byte, error) {
	f := g.newFile(sourceName)
	if g.tctx.SQLDriver.IsPGX() {
		g.addQueryCodePGX(f, sourceName)
	} else {
		g.addQueryCodeStd(f, sourceName)
	}
	return poet.Render(f)
}

// GenerateCopyFromFile generates the copyfrom.go file content.
func (g *CodeGenerator) GenerateCopyFromFile() ([]byte, error) {
	f := g.newFile(g.tctx.SourceName)
	if g.tctx.SQLDriver.IsPGX() {
		g.addCopyFromCodePGX(f)
	} else if g.tctx.SQLDriver.IsGoSQLDriverMySQL() {
		g.addCopyFromCodeMySQL(f)
	}
	return poet.Render(f)
}

// GenerateBatchFile generates the batch.go file content.
func (g *CodeGenerator) GenerateBatchFile() ([]byte, error) {
	f := g.newFile(g.tctx.SourceName)
	g.addBatchCodePGX(f)
	return poet.Render(f)
}

func (g *CodeGenerator) newFile(sourceComment string) *poet.File {
	f := &poet.File{
		BuildTags: g.tctx.BuildTags,
		Package:   g.tctx.Package,
	}

	// File comments
	f.Comments = append(f.Comments, "// Code generated by sqlc. DO NOT EDIT.")
	if !g.tctx.OmitSqlcVersion {
		f.Comments = append(f.Comments, "// versions:")
		f.Comments = append(f.Comments, "//   sqlc "+g.tctx.SqlcVersion)
	}
	if sourceComment != "" {
		f.Comments = append(f.Comments, "// source: "+sourceComment)
	}

	// Imports - two groups: stdlib and third-party, separated by blank line
	imports := g.i.Imports(g.tctx.SourceName)
	var stdlibImports, thirdPartyImports []poet.Import
	for _, imp := range imports[0] {
		stdlibImports = append(stdlibImports, poet.Import{Path: imp.Path, Alias: imp.ID})
	}
	for _, imp := range imports[1] {
		thirdPartyImports = append(thirdPartyImports, poet.Import{Path: imp.Path, Alias: imp.ID})
	}
	f.ImportGroups = [][]poet.Import{stdlibImports, thirdPartyImports}

	return f
}

func (g *CodeGenerator) addDBCodeStd(f *poet.File) {
	// DBTX interface
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "DBTX",
		Type: poet.Interface{
			Methods: []poet.Method{
				{Name: "ExecContext", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "sql.Result"}, {Type: "error"}}},
				{Name: "PrepareContext", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}}, Results: []poet.Param{{Type: "*sql.Stmt"}, {Type: "error"}}},
				{Name: "QueryContext", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "*sql.Rows"}, {Type: "error"}}},
				{Name: "QueryRowContext", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "*sql.Row"}}},
			},
		},
	})

	// New function
	if g.tctx.EmitMethodsWithDBArgument {
		f.Decls = append(f.Decls, poet.Func{
			Name:    "New",
			Results: []poet.Param{{Type: "Queries", Pointer: true}},
			Stmts: []poet.Stmt{poet.Return{Values: []string{
				poet.StructLit{Type: "Queries", Pointer: true}.Render(),
			}}},
		})
	} else {
		f.Decls = append(f.Decls, poet.Func{
			Name:    "New",
			Params:  []poet.Param{{Name: "db", Type: "DBTX"}},
			Results: []poet.Param{{Type: "Queries", Pointer: true}},
			Stmts: []poet.Stmt{poet.Return{Values: []string{
				poet.StructLit{Type: "Queries", Pointer: true, Fields: [][2]string{
					{"db", "db"},
				}}.Render(),
			}}},
		})
	}

	// Prepare and Close functions for prepared queries
	if g.tctx.EmitPreparedQueries {
		// Build Prepare function statements
		var prepareStmts []poet.Stmt
		prepareStmts = append(prepareStmts, poet.Assign{
			Left:  []string{"q"},
			Op:    ":=",
			Right: []string{poet.StructLit{Type: "Queries", Fields: [][2]string{{"db", "db"}}}.Render()},
		})
		prepareStmts = append(prepareStmts, poet.VarDecl{Name: "err", Type: "error"})
		if len(g.tctx.GoQueries) == 0 {
			prepareStmts = append(prepareStmts, poet.Assign{Left: []string{"_"}, Op: "=", Right: []string{"err"}})
		}
		for _, query := range g.tctx.GoQueries {
			prepareStmts = append(prepareStmts, poet.If{
				Init: fmt.Sprintf("q.%s, err = db.PrepareContext(ctx, %s)", query.FieldName, query.ConstantName),
				Cond: "err != nil",
				Body: []poet.Stmt{poet.Return{Values: []string{
					"nil",
					fmt.Sprintf(`fmt.Errorf("error preparing query %s: %%w", err)`, query.MethodName),
				}}},
			})
		}
		prepareStmts = append(prepareStmts, poet.Return{Values: []string{"&q", "nil"}})

		f.Decls = append(f.Decls, poet.Func{
			Name:    "Prepare",
			Params:  []poet.Param{{Name: "ctx", Type: "context.Context"}, {Name: "db", Type: "DBTX"}},
			Results: []poet.Param{{Type: "*Queries"}, {Type: "error"}},
			Stmts:   prepareStmts,
		})

		// Build Close function statements
		var closeStmts []poet.Stmt
		closeStmts = append(closeStmts, poet.VarDecl{Name: "err", Type: "error"})
		for _, query := range g.tctx.GoQueries {
			closeStmts = append(closeStmts, poet.If{
				Cond: fmt.Sprintf("q.%s != nil", query.FieldName),
				Body: []poet.Stmt{poet.If{
					Init: fmt.Sprintf("cerr := q.%s.Close()", query.FieldName),
					Cond: "cerr != nil",
					Body: []poet.Stmt{poet.Assign{
						Left:  []string{"err"},
						Op:    "=",
						Right: []string{fmt.Sprintf(`fmt.Errorf("error closing %s: %%w", cerr)`, query.FieldName)},
					}},
				}},
			})
		}
		closeStmts = append(closeStmts, poet.Return{Values: []string{"err"}})

		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    "Close",
			Results: []poet.Param{{Type: "error"}},
			Stmts:   closeStmts,
		})

		// Helper functions
		f.Decls = append(f.Decls, poet.Func{
			Recv: &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name: "exec",
			Params: []poet.Param{
				{Name: "ctx", Type: "context.Context"},
				{Name: "stmt", Type: "sql.Stmt", Pointer: true},
				{Name: "query", Type: "string"},
				{Name: "args", Type: "...interface{}"},
			},
			Results: []poet.Param{{Type: "sql.Result"}, {Type: "error"}},
			Stmts: []poet.Stmt{poet.Switch{
				Cases: []poet.Case{
					{
						Values: []string{"stmt != nil && q.tx != nil"},
						Body: []poet.Stmt{poet.Return{
							Values: []string{
								"q.tx.StmtContext(ctx, stmt).ExecContext(ctx, args...)",
							},
						}},
					},
					{
						Values: []string{"stmt != nil"},
						Body: []poet.Stmt{poet.Return{
							Values: []string{"stmt.ExecContext(ctx, args...)"},
						}},
					},
					{
						Body: []poet.Stmt{poet.Return{
							Values: []string{"q.db.ExecContext(ctx, query, args...)"},
						}},
					},
				},
			}},
		})

		f.Decls = append(f.Decls, poet.Func{
			Recv: &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name: "query",
			Params: []poet.Param{
				{Name: "ctx", Type: "context.Context"},
				{Name: "stmt", Type: "sql.Stmt", Pointer: true},
				{Name: "query", Type: "string"},
				{Name: "args", Type: "...interface{}"},
			},
			Results: []poet.Param{{Type: "sql.Rows", Pointer: true}, {Type: "error"}},
			Stmts: []poet.Stmt{poet.Switch{
				Cases: []poet.Case{
					{
						Values: []string{"stmt != nil && q.tx != nil"},
						Body: []poet.Stmt{poet.Return{
							Values: []string{
								"q.tx.StmtContext(ctx, stmt).QueryContext(ctx, args...)",
							},
						}},
					},
					{
						Values: []string{"stmt != nil"},
						Body: []poet.Stmt{poet.Return{
							Values: []string{"stmt.QueryContext(ctx, args...)"},
						}},
					},
					{
						Body: []poet.Stmt{poet.Return{
							Values: []string{"q.db.QueryContext(ctx, query, args...)"},
						}},
					},
				},
			}},
		})

		f.Decls = append(f.Decls, poet.Func{
			Recv: &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name: "queryRow",
			Params: []poet.Param{
				{Name: "ctx", Type: "context.Context"},
				{Name: "stmt", Type: "sql.Stmt", Pointer: true},
				{Name: "query", Type: "string"},
				{Name: "args", Type: "...interface{}"},
			},
			Results: []poet.Param{{Type: "sql.Row", Pointer: true}},
			Stmts: []poet.Stmt{poet.Switch{
				Cases: []poet.Case{
					{
						Values: []string{"stmt != nil && q.tx != nil"},
						Body: []poet.Stmt{poet.Return{
							Values: []string{
								"q.tx.StmtContext(ctx, stmt).QueryRowContext(ctx, args...)",
							},
						}},
					},
					{
						Values: []string{"stmt != nil"},
						Body: []poet.Stmt{poet.Return{
							Values: []string{"stmt.QueryRowContext(ctx, args...)"},
						}},
					},
					{
						Body: []poet.Stmt{poet.Return{
							Values: []string{"q.db.QueryRowContext(ctx, query, args...)"},
						}},
					},
				},
			}},
		})
	}

	// Queries struct
	var fields []poet.Field
	if !g.tctx.EmitMethodsWithDBArgument {
		fields = append(fields, poet.Field{Name: "db", Type: "DBTX"})
	}
	if g.tctx.EmitPreparedQueries {
		fields = append(fields, poet.Field{Name: "tx", Type: "*sql.Tx"})
		for _, query := range g.tctx.GoQueries {
			fields = append(fields, poet.Field{Name: query.FieldName, Type: "*sql.Stmt"})
		}
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "Queries",
		Type: poet.Struct{Fields: fields},
	})

	// WithTx method
	if !g.tctx.EmitMethodsWithDBArgument {
		withTxFields := [][2]string{{"db", "tx"}}
		if g.tctx.EmitPreparedQueries {
			withTxFields = append(withTxFields, [2]string{"tx", "tx"})
			for _, query := range g.tctx.GoQueries {
				withTxFields = append(withTxFields, [2]string{query.FieldName, "q." + query.FieldName})
			}
		}
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    "WithTx",
			Params:  []poet.Param{{Name: "tx", Type: "*sql.Tx"}},
			Results: []poet.Param{{Type: "*Queries"}},
			Stmts: []poet.Stmt{poet.Return{Values: []string{
				poet.StructLit{Type: "Queries", Pointer: true, Multiline: true, Fields: withTxFields}.Render(),
			}}},
		})
	}
}

func (g *CodeGenerator) addDBCodePGX(f *poet.File) {
	// DBTX interface
	methods := []poet.Method{
		{Name: "Exec", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "pgconn.CommandTag"}, {Type: "error"}}},
		{Name: "Query", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "pgx.Rows"}, {Type: "error"}}},
		{Name: "QueryRow", Params: []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "string"}, {Name: "", Type: "...interface{}"}}, Results: []poet.Param{{Type: "pgx.Row"}}},
	}
	if g.tctx.UsesCopyFrom {
		methods = append(methods, poet.Method{
			Name:    "CopyFrom",
			Params:  []poet.Param{{Name: "ctx", Type: "context.Context"}, {Name: "tableName", Type: "pgx.Identifier"}, {Name: "columnNames", Type: "[]string"}, {Name: "rowSrc", Type: "pgx.CopyFromSource"}},
			Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
		})
	}
	if g.tctx.UsesBatch {
		methods = append(methods, poet.Method{
			Name:    "SendBatch",
			Params:  []poet.Param{{Name: "", Type: "context.Context"}, {Name: "", Type: "*pgx.Batch"}},
			Results: []poet.Param{{Type: "pgx.BatchResults"}},
		})
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "DBTX",
		Type: poet.Interface{Methods: methods},
	})

	// New function
	if g.tctx.EmitMethodsWithDBArgument {
		f.Decls = append(f.Decls, poet.Func{
			Name:    "New",
			Results: []poet.Param{{Type: "Queries", Pointer: true}},
			Stmts: []poet.Stmt{poet.Return{Values: []string{
				poet.StructLit{Type: "Queries", Pointer: true}.Render(),
			}}},
		})
	} else {
		f.Decls = append(f.Decls, poet.Func{
			Name:    "New",
			Params:  []poet.Param{{Name: "db", Type: "DBTX"}},
			Results: []poet.Param{{Type: "Queries", Pointer: true}},
			Stmts: []poet.Stmt{poet.Return{Values: []string{
				poet.StructLit{Type: "Queries", Pointer: true, Fields: [][2]string{
					{"db", "db"},
				}}.Render(),
			}}},
		})
	}

	// Queries struct
	var fields []poet.Field
	if !g.tctx.EmitMethodsWithDBArgument {
		fields = append(fields, poet.Field{Name: "db", Type: "DBTX"})
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "Queries",
		Type: poet.Struct{Fields: fields},
	})

	// WithTx method
	if !g.tctx.EmitMethodsWithDBArgument {
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name:    "WithTx",
			Params:  []poet.Param{{Name: "tx", Type: "pgx.Tx"}},
			Results: []poet.Param{{Type: "Queries", Pointer: true}},
			Stmts: []poet.Stmt{poet.Return{Values: []string{
				poet.StructLit{Type: "Queries", Pointer: true, Multiline: true, Fields: [][2]string{
					{"db", "tx"},
				}}.Render(),
			}}},
		})
	}
}

func (g *CodeGenerator) addModelsCode(f *poet.File) {
	// Enums
	for _, enum := range g.tctx.Enums {
		// Type alias
		f.Decls = append(f.Decls, poet.TypeDef{
			Comment: enum.Comment,
			Name:    enum.Name,
			Type:    poet.TypeName{Name: "string"},
		})

		// Constants
		var consts []poet.Const
		for _, c := range enum.Constants {
			consts = append(consts, poet.Const{
				Name:  c.Name,
				Type:  c.Type,
				Value: fmt.Sprintf("%q", c.Value),
			})
		}
		f.Decls = append(f.Decls, poet.ConstBlock{Consts: consts})

		// Scan method
		typeCast := poet.TypeCast{Type: enum.Name, Value: "s"}.Render()
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "e", Type: enum.Name, Pointer: true},
			Name:    "Scan",
			Params:  []poet.Param{{Name: "src", Type: "interface{}"}},
			Results: []poet.Param{{Type: "error"}},
			Stmts: []poet.Stmt{
				poet.Switch{
					Expr: "s := src.(type)",
					Cases: []poet.Case{
						{
							Values: []string{"[]byte"},
							Body: []poet.Stmt{
								poet.Assign{Left: []string{"*e"}, Op: "=", Right: []string{typeCast}},
							},
						},
						{
							Values: []string{"string"},
							Body: []poet.Stmt{
								poet.Assign{Left: []string{"*e"}, Op: "=", Right: []string{typeCast}},
							},
						},
						{
							Body: []poet.Stmt{poet.Return{Values: []string{
								poet.CallExpr{
									Func: "fmt.Errorf",
									Args: []string{fmt.Sprintf(`"unsupported scan type for %s: %%T"`, enum.Name), "src"},
								}.Render(),
							}}},
						},
					},
				},
				poet.Return{Values: []string{"nil"}},
			},
		})

		// Null type
		var nullFields []poet.Field
		if enum.NameTag() != "" {
			nullFields = append(nullFields, poet.Field{
				Name: enum.Name, Type: enum.Name, Tag: enum.NameTag(),
			})
		} else {
			nullFields = append(nullFields, poet.Field{
				Name: enum.Name, Type: enum.Name,
			})
		}
		validComment := fmt.Sprintf("Valid is true if %s is not NULL", enum.Name)
		if enum.ValidTag() != "" {
			nullFields = append(nullFields, poet.Field{
				Name: "Valid", Type: "bool", Tag: enum.ValidTag(),
				TrailingComment: validComment,
			})
		} else {
			nullFields = append(nullFields, poet.Field{
				Name: "Valid", Type: "bool", TrailingComment: validComment,
			})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: "Null" + enum.Name,
			Type: poet.Struct{Fields: nullFields},
		})

		// Null Scan method
		f.Decls = append(f.Decls, poet.Func{
			Comment: "Scan implements the Scanner interface.",
			Recv:    &poet.Param{Name: "ns", Type: "Null" + enum.Name, Pointer: true},
			Name:    "Scan",
			Params:  []poet.Param{{Name: "value", Type: "interface{}"}},
			Results: []poet.Param{{Type: "error"}},
			Stmts: []poet.Stmt{
				poet.If{
					Cond: "value == nil",
					Body: []poet.Stmt{
						poet.Assign{
							Left:  []string{"ns." + enum.Name, "ns.Valid"},
							Op:    "=",
							Right: []string{`""`, "false"},
						},
						poet.Return{Values: []string{"nil"}},
					},
				},
				poet.Assign{Left: []string{"ns.Valid"}, Op: "=", Right: []string{"true"}},
				poet.Return{Values: []string{fmt.Sprintf("ns.%s.Scan(value)", enum.Name)}},
			},
		})

		// Null Value method
		f.Decls = append(f.Decls, poet.Func{
			Comment: "Value implements the driver Valuer interface.",
			Recv:    &poet.Param{Name: "ns", Type: "Null" + enum.Name},
			Name:    "Value",
			Results: []poet.Param{{Type: "driver.Value"}, {Type: "error"}},
			Stmts: []poet.Stmt{
				poet.If{
					Cond: "!ns.Valid",
					Body: []poet.Stmt{poet.Return{Values: []string{"nil", "nil"}}},
				},
				poet.Return{Values: []string{
					poet.TypeCast{Type: "string", Value: "ns." + enum.Name}.Render(),
					"nil",
				}},
			},
		})

		// Valid method
		if g.tctx.EmitEnumValidMethod {
			var caseValues []string
			for _, c := range enum.Constants {
				caseValues = append(caseValues, c.Name)
			}
			f.Decls = append(f.Decls, poet.Func{
				Recv:    &poet.Param{Name: "e", Type: enum.Name},
				Name:    "Valid",
				Results: []poet.Param{{Type: "bool"}},
				Stmts: []poet.Stmt{
					poet.Switch{
						Expr: "e",
						Cases: []poet.Case{
							{Values: caseValues, Body: []poet.Stmt{poet.Return{Values: []string{"true"}}}},
						},
					},
					poet.Return{Values: []string{"false"}},
				},
			})
		}

		// AllValues method
		if g.tctx.EmitAllEnumValues {
			var enumValues []string
			for _, c := range enum.Constants {
				enumValues = append(enumValues, c.Name)
			}
			f.Decls = append(f.Decls, poet.Func{
				Name:    fmt.Sprintf("All%sValues", enum.Name),
				Results: []poet.Param{{Type: "[]" + enum.Name}},
				Stmts: []poet.Stmt{poet.Return{Values: []string{
					poet.SliceLit{Type: enum.Name, Multiline: true, Values: enumValues}.Render(),
				}}},
			})
		}
	}

	// Structs
	for _, s := range g.tctx.Structs {
		var fields []poet.Field
		for _, fld := range s.Fields {
			fields = append(fields, poet.Field{
				Comment: fld.Comment,
				Name:    fld.Name,
				Type:    fld.Type,
				Tag:     fld.Tag(),
			})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Comment: s.Comment,
			Name:    s.Name,
			Type:    poet.Struct{Fields: fields},
		})
	}
}

func (g *CodeGenerator) addInterfaceCodeStd(f *poet.File) {
	var methods []poet.Method
	for _, q := range g.tctx.GoQueries {
		m := g.buildInterfaceMethod(q, false)
		if m != nil {
			methods = append(methods, *m)
		}
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "Querier",
		Type: poet.Interface{Methods: methods},
	})
	f.Decls = append(f.Decls, poet.Var{
		Name:  "_",
		Type:  "Querier",
		Value: "(*Queries)(nil)",
	})
}

func (g *CodeGenerator) addInterfaceCodePGX(f *poet.File) {
	var methods []poet.Method
	for _, q := range g.tctx.GoQueries {
		m := g.buildInterfaceMethod(q, true)
		if m != nil {
			methods = append(methods, *m)
		}
	}
	f.Decls = append(f.Decls, poet.TypeDef{
		Name: "Querier",
		Type: poet.Interface{Methods: methods},
	})
	f.Decls = append(f.Decls, poet.Var{
		Name:  "_",
		Type:  "Querier",
		Value: "(*Queries)(nil)",
	})
}

func (g *CodeGenerator) buildInterfaceMethod(q Query, isPGX bool) *poet.Method {
	var params string
	var returnType string

	switch q.Cmd {
	case ":one":
		params = q.Arg.Pair()
		returnType = fmt.Sprintf("(%s, error)", q.Ret.DefineType())
	case ":many":
		params = q.Arg.Pair()
		returnType = fmt.Sprintf("([]%s, error)", q.Ret.DefineType())
	case ":exec":
		params = q.Arg.Pair()
		returnType = "error"
	case ":execrows":
		params = q.Arg.Pair()
		returnType = "(int64, error)"
	case ":execlastid":
		params = q.Arg.Pair()
		returnType = "(int64, error)"
	case ":execresult":
		params = q.Arg.Pair()
		if isPGX {
			returnType = "(pgconn.CommandTag, error)"
		} else {
			returnType = "(sql.Result, error)"
		}
	case ":copyfrom":
		params = q.Arg.SlicePair()
		returnType = "(int64, error)"
	case ":batchexec", ":batchmany", ":batchone":
		params = q.Arg.SlicePair()
		returnType = fmt.Sprintf("*%sBatchResults", q.MethodName)
	default:
		return nil
	}

	if g.tctx.EmitMethodsWithDBArgument {
		if params != "" {
			params = "db DBTX, " + params
		} else {
			params = "db DBTX"
		}
	}

	comment := ""
	for _, c := range q.Comments {
		comment += "//" + c + "\n"
	}
	comment = strings.TrimSuffix(comment, "\n")

	// Build params list
	var paramList []poet.Param
	paramList = append(paramList, poet.Param{Name: "ctx", Type: "context.Context"})
	if params != "" {
		paramList = append(paramList, poet.Param{Name: "", Type: params})
	}

	return &poet.Method{
		Comment: comment,
		Name:    q.MethodName,
		Params:  paramList,
		Results: []poet.Param{{Type: returnType}},
	}
}

func (g *CodeGenerator) addQueryCodeStd(f *poet.File, sourceName string) {
	for _, q := range g.tctx.GoQueries {
		if q.SourceName != sourceName {
			continue
		}
		g.addQueryStd(f, q)
	}
}

func (g *CodeGenerator) addQueryStd(f *poet.File, q Query) {
	// SQL constant
	f.Decls = append(f.Decls, poet.Const{
		Name:  q.ConstantName,
		Value: fmt.Sprintf("`-- name: %s %s\n%s\n`", q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL)),
	})

	// Arg struct if needed
	if q.Arg.EmitStruct() {
		var fields []poet.Field
		for _, fld := range q.Arg.UniqueFields() {
			fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.Arg.Type(),
			Type: poet.Struct{Fields: fields},
		})
	}

	// Ret struct if needed
	if q.Ret.EmitStruct() {
		var fields []poet.Field
		for _, fld := range q.Ret.Struct.Fields {
			fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.Ret.Type(),
			Type: poet.Struct{Fields: fields},
		})
	}

	// Method
	switch q.Cmd {
	case ":one":
		g.addQueryOneStd(f, q)
	case ":many":
		g.addQueryManyStd(f, q)
	case ":exec":
		g.addQueryExecStd(f, q)
	case ":execrows":
		g.addQueryExecRowsStd(f, q)
	case ":execlastid":
		g.addQueryExecLastIDStd(f, q)
	case ":execresult":
		g.addQueryExecResultStd(f, q)
	}
}

func (g *CodeGenerator) queryComments(q Query) string {
	var comment string
	for _, c := range q.Comments {
		comment += "//" + c + "\n"
	}
	return strings.TrimSuffix(comment, "\n")
}

func (g *CodeGenerator) addQueryOneStd(f *poet.File, q Query) {
	params := g.buildQueryParams(q)

	// Fall back to RawStmt for slice queries (complex handling)
	if q.Arg.HasSqlcSlices() {
		var stmts []poet.Stmt

		// Query exec call (complex dynamic SQL handling)
		var queryExec strings.Builder
		g.writeQueryExecStdCall(&queryExec, q, "row :=")
		stmts = append(stmts, poet.RawStmt{Code: queryExec.String()})

		// var <name> <type> (if arg and ret are different)
		if q.Arg.Pair() != q.Ret.Pair() || q.Arg.DefineType() != q.Ret.DefineType() {
			stmts = append(stmts, poet.VarDecl{Name: q.Ret.Name, Type: q.Ret.Type()})
		}

		// err := row.Scan(<scan args>)
		stmts = append(stmts, poet.Assign{
			Left:  []string{"err"},
			Op:    ":=",
			Right: []string{fmt.Sprintf("row.Scan(%s)", q.Ret.Scan())},
		})

		// if err != nil { err = fmt.Errorf(...) }
		if g.tctx.WrapErrors {
			stmts = append(stmts, poet.If{
				Cond: "err != nil",
				Body: []poet.Stmt{
					poet.Assign{
						Left:  []string{"err"},
						Op:    "=",
						Right: []string{fmt.Sprintf(`fmt.Errorf("query %s: %%w", err)`, q.MethodName)},
					},
				},
			})
		}

		// return <name>, err
		stmts = append(stmts, poet.Return{Values: []string{q.Ret.ReturnName(), "err"}})

		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: q.Ret.DefineType()}, {Type: "error"}},
			Stmts:   stmts,
		})
		return
	}

	var stmts []poet.Stmt

	// row := <query call>
	stmts = append(stmts, poet.Assign{
		Left:  []string{"row"},
		Op:    ":=",
		Right: []string{g.queryExecStdCallExpr(q)},
	})

	// var <name> <type> (if arg and ret are different)
	if q.Arg.Pair() != q.Ret.Pair() || q.Arg.DefineType() != q.Ret.DefineType() {
		stmts = append(stmts, poet.VarDecl{Name: q.Ret.Name, Type: q.Ret.Type()})
	}

	// err := row.Scan(<scan args>)
	stmts = append(stmts, poet.Assign{
		Left:  []string{"err"},
		Op:    ":=",
		Right: []string{fmt.Sprintf("row.Scan(%s)", q.Ret.Scan())},
	})

	// if err != nil { err = fmt.Errorf(...) }
	if g.tctx.WrapErrors {
		stmts = append(stmts, poet.If{
			Cond: "err != nil",
			Body: []poet.Stmt{
				poet.Assign{
					Left:  []string{"err"},
					Op:    "=",
					Right: []string{fmt.Sprintf(`fmt.Errorf("query %s: %%w", err)`, q.MethodName)},
				},
			},
		})
	}

	// return <name>, err
	stmts = append(stmts, poet.Return{Values: []string{q.Ret.ReturnName(), "err"}})

	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: q.Ret.DefineType()}, {Type: "error"}},
		Stmts:   stmts,
	})
}

func (g *CodeGenerator) addQueryManyStd(f *poet.File, q Query) {
	params := g.buildQueryParams(q)

	// Fall back to RawStmt for slice queries (complex handling)
	if q.Arg.HasSqlcSlices() {
		var stmts []poet.Stmt

		// Query exec call (complex dynamic SQL handling)
		var queryExec strings.Builder
		g.writeQueryExecStdCall(&queryExec, q, "rows, err :=")
		stmts = append(stmts, poet.RawStmt{Code: queryExec.String()})

		// if err != nil { return nil, err }
		errReturn := g.wrapErrorReturn(q, "nil")
		stmts = append(stmts, poet.If{
			Cond: "err != nil",
			Body: []poet.Stmt{poet.Return{Values: errReturn}},
		})

		// defer rows.Close()
		stmts = append(stmts, poet.Defer{Call: "rows.Close()"})

		// var items []<type> or items := []<type>{}
		if g.tctx.EmitEmptySlices {
			stmts = append(stmts, poet.Assign{
				Left:  []string{"items"},
				Op:    ":=",
				Right: []string{fmt.Sprintf("[]%s{}", q.Ret.DefineType())},
			})
		} else {
			stmts = append(stmts, poet.VarDecl{
				Name: "items",
				Type: "[]" + q.Ret.DefineType(),
			})
		}

		// for rows.Next() { ... }
		scanErrReturn := g.wrapErrorReturn(q, "nil")
		stmts = append(stmts, poet.For{
			Range: "rows.Next()",
			Body: []poet.Stmt{
				poet.VarDecl{Name: q.Ret.Name, Type: q.Ret.Type()},
				poet.If{
					Init: fmt.Sprintf("err := rows.Scan(%s)", q.Ret.Scan()),
					Cond: "err != nil",
					Body: []poet.Stmt{poet.Return{Values: scanErrReturn}},
				},
				poet.Assign{
					Left:  []string{"items"},
					Op:    "=",
					Right: []string{fmt.Sprintf("append(items, %s)", q.Ret.ReturnName())},
				},
			},
		})

		// if err := rows.Close(); err != nil { return nil, err }
		closeErrReturn := g.wrapErrorReturn(q, "nil")
		stmts = append(stmts, poet.If{
			Init: "err := rows.Close()",
			Cond: "err != nil",
			Body: []poet.Stmt{poet.Return{Values: closeErrReturn}},
		})

		// if err := rows.Err(); err != nil { return nil, err }
		rowsErrReturn := g.wrapErrorReturn(q, "nil")
		stmts = append(stmts, poet.If{
			Init: "err := rows.Err()",
			Cond: "err != nil",
			Body: []poet.Stmt{poet.Return{Values: rowsErrReturn}},
		})

		// return items, nil
		stmts = append(stmts, poet.Return{Values: []string{"items", "nil"}})

		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "[]" + q.Ret.DefineType()}, {Type: "error"}},
			Stmts:   stmts,
		})
		return
	}

	var stmts []poet.Stmt

	// rows, err := <query call>
	stmts = append(stmts, poet.Assign{
		Left:  []string{"rows", "err"},
		Op:    ":=",
		Right: []string{g.queryExecStdCallExpr(q)},
	})

	// if err != nil { return nil, err }
	errReturn := g.wrapErrorReturn(q, "nil")
	stmts = append(stmts, poet.If{
		Cond: "err != nil",
		Body: []poet.Stmt{poet.Return{Values: errReturn}},
	})

	// defer rows.Close()
	stmts = append(stmts, poet.Defer{Call: "rows.Close()"})

	// var items []<type> or items := []<type>{}
	if g.tctx.EmitEmptySlices {
		stmts = append(stmts, poet.Assign{
			Left:  []string{"items"},
			Op:    ":=",
			Right: []string{fmt.Sprintf("[]%s{}", q.Ret.DefineType())},
		})
	} else {
		stmts = append(stmts, poet.VarDecl{
			Name: "items",
			Type: "[]" + q.Ret.DefineType(),
		})
	}

	// for rows.Next() { ... }
	scanErrReturn := g.wrapErrorReturn(q, "nil")
	stmts = append(stmts, poet.For{
		Range: "rows.Next()",
		Body: []poet.Stmt{
			poet.VarDecl{Name: q.Ret.Name, Type: q.Ret.Type()},
			poet.If{
				Init: fmt.Sprintf("err := rows.Scan(%s)", q.Ret.Scan()),
				Cond: "err != nil",
				Body: []poet.Stmt{poet.Return{Values: scanErrReturn}},
			},
			poet.Assign{
				Left:  []string{"items"},
				Op:    "=",
				Right: []string{fmt.Sprintf("append(items, %s)", q.Ret.ReturnName())},
			},
		},
	})

	// if err := rows.Close(); err != nil { return nil, err }
	closeErrReturn := g.wrapErrorReturn(q, "nil")
	stmts = append(stmts, poet.If{
		Init: "err := rows.Close()",
		Cond: "err != nil",
		Body: []poet.Stmt{poet.Return{Values: closeErrReturn}},
	})

	// if err := rows.Err(); err != nil { return nil, err }
	rowsErrReturn := g.wrapErrorReturn(q, "nil")
	stmts = append(stmts, poet.If{
		Init: "err := rows.Err()",
		Cond: "err != nil",
		Body: []poet.Stmt{poet.Return{Values: rowsErrReturn}},
	})

	// return items, nil
	stmts = append(stmts, poet.Return{Values: []string{"items", "nil"}})

	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "[]" + q.Ret.DefineType()}, {Type: "error"}},
		Stmts:   stmts,
	})
}

// wrapErrorReturn returns the return values for an error return.
// firstVal is the first value to return (e.g., "nil", "0").
func (g *CodeGenerator) wrapErrorReturn(q Query, firstVal string) []string {
	if g.tctx.WrapErrors {
		return []string{firstVal, fmt.Sprintf(`fmt.Errorf("query %s: %%w", err)`, q.MethodName)}
	}
	return []string{firstVal, "err"}
}

func (g *CodeGenerator) addQueryExecStd(f *poet.File, q Query) {
	params := g.buildQueryParams(q)

	// Fall back to RawStmt for slice queries (complex handling)
	if q.Arg.HasSqlcSlices() {
		var body strings.Builder
		g.writeQueryExecStdCall(&body, q, "_, err :=")
		if g.tctx.WrapErrors {
			body.WriteString("\tif err != nil {\n")
			fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
			body.WriteString("\t}\n")
		}
		body.WriteString("\treturn err\n")
		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "error"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
		})
		return
	}

	var stmts []poet.Stmt
	stmts = append(stmts, poet.Assign{
		Left:  []string{"_", "err"},
		Op:    ":=",
		Right: []string{g.queryExecStdCallExpr(q)},
	})

	if g.tctx.WrapErrors {
		stmts = append(stmts, poet.If{
			Cond: "err != nil",
			Body: []poet.Stmt{
				poet.Assign{
					Left:  []string{"err"},
					Op:    "=",
					Right: []string{fmt.Sprintf(`fmt.Errorf("query %s: %%w", err)`, q.MethodName)},
				},
			},
		})
	}
	stmts = append(stmts, poet.Return{Values: []string{"err"}})

	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "error"}},
		Stmts:   stmts,
	})
}

func (g *CodeGenerator) addQueryExecRowsStd(f *poet.File, q Query) {
	params := g.buildQueryParams(q)

	// Fall back to RawStmt for slice queries
	if q.Arg.HasSqlcSlices() {
		var body strings.Builder
		g.writeQueryExecStdCall(&body, q, "result, err :=")
		body.WriteString("\tif err != nil {\n")
		if g.tctx.WrapErrors {
			fmt.Fprintf(&body, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		} else {
			body.WriteString("\t\treturn 0, err\n")
		}
		body.WriteString("\t}\n")
		body.WriteString("\treturn result.RowsAffected()\n")
		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
		})
		return
	}

	var stmts []poet.Stmt

	// result, err := <query call>
	stmts = append(stmts, poet.Assign{
		Left:  []string{"result", "err"},
		Op:    ":=",
		Right: []string{g.queryExecStdCallExpr(q)},
	})

	// if err != nil { return 0, err }
	errReturn := g.wrapErrorReturn(q, "0")
	stmts = append(stmts, poet.If{
		Cond: "err != nil",
		Body: []poet.Stmt{poet.Return{Values: errReturn}},
	})

	// return result.RowsAffected()
	stmts = append(stmts, poet.Return{Values: []string{"result.RowsAffected()"}})

	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
		Stmts:   stmts,
	})
}

func (g *CodeGenerator) addQueryExecLastIDStd(f *poet.File, q Query) {
	params := g.buildQueryParams(q)

	// Fall back to RawStmt for slice queries
	if q.Arg.HasSqlcSlices() {
		var body strings.Builder
		g.writeQueryExecStdCall(&body, q, "result, err :=")
		body.WriteString("\tif err != nil {\n")
		if g.tctx.WrapErrors {
			fmt.Fprintf(&body, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		} else {
			body.WriteString("\t\treturn 0, err\n")
		}
		body.WriteString("\t}\n")
		body.WriteString("\treturn result.LastInsertId()\n")
		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
		})
		return
	}

	var stmts []poet.Stmt

	// result, err := <query call>
	stmts = append(stmts, poet.Assign{
		Left:  []string{"result", "err"},
		Op:    ":=",
		Right: []string{g.queryExecStdCallExpr(q)},
	})

	// if err != nil { return 0, err }
	errReturn := g.wrapErrorReturn(q, "0")
	stmts = append(stmts, poet.If{
		Cond: "err != nil",
		Body: []poet.Stmt{poet.Return{Values: errReturn}},
	})

	// return result.LastInsertId()
	stmts = append(stmts, poet.Return{Values: []string{"result.LastInsertId()"}})

	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
		Stmts:   stmts,
	})
}

func (g *CodeGenerator) addQueryExecResultStd(f *poet.File, q Query) {
	params := g.buildQueryParams(q)

	// Fall back to RawStmt for slice queries
	if q.Arg.HasSqlcSlices() {
		var body strings.Builder
		if g.tctx.WrapErrors {
			g.writeQueryExecStdCall(&body, q, "result, err :=")
			body.WriteString("\tif err != nil {\n")
			fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
			body.WriteString("\t}\n")
			body.WriteString("\treturn result, err\n")
		} else {
			g.writeQueryExecStdCall(&body, q, "return")
		}
		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "sql.Result"}, {Type: "error"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
		})
		return
	}

	var stmts []poet.Stmt

	if g.tctx.WrapErrors {
		// result, err := <query call>
		stmts = append(stmts, poet.Assign{
			Left:  []string{"result", "err"},
			Op:    ":=",
			Right: []string{g.queryExecStdCallExpr(q)},
		})

		// if err != nil { err = fmt.Errorf(...) }
		stmts = append(stmts, poet.If{
			Cond: "err != nil",
			Body: []poet.Stmt{
				poet.Assign{
					Left:  []string{"err"},
					Op:    "=",
					Right: []string{fmt.Sprintf(`fmt.Errorf("query %s: %%w", err)`, q.MethodName)},
				},
			},
		})

		// return result, err
		stmts = append(stmts, poet.Return{Values: []string{"result", "err"}})
	} else {
		// return <query call>
		stmts = append(stmts, poet.Return{Values: []string{g.queryExecStdCallExpr(q)}})
	}

	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "Queries", Pointer: true},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "sql.Result"}, {Type: "error"}},
		Stmts:   stmts,
	})
}

func (g *CodeGenerator) buildQueryParams(q Query) []poet.Param {
	var params []poet.Param
	params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
	if g.tctx.EmitMethodsWithDBArgument {
		params = append(params, poet.Param{Name: "db", Type: "DBTX"})
	}
	if q.Arg.Pair() != "" {
		// Parse the pair into name and type
		pair := q.Arg.Pair()
		if pair != "" {
			params = append(params, poet.Param{Name: "", Type: pair})
		}
	}
	return params
}

func (g *CodeGenerator) writeQueryExecStdCall(body *strings.Builder, q Query, retval string) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	if q.Arg.HasSqlcSlices() {
		g.writeQuerySliceExec(body, q, retval, db, false)
		return
	}

	fmt.Fprintf(body, "\t%s %s\n", retval, g.queryExecStdCallExpr(q))
}

// queryExecStdCallExpr returns the method call expression for a query.
func (g *CodeGenerator) queryExecStdCallExpr(q Query) string {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var method string
	switch q.Cmd {
	case ":one":
		if g.tctx.EmitPreparedQueries {
			method = "q.queryRow"
		} else {
			method = db + ".QueryRowContext"
		}
	case ":many":
		if g.tctx.EmitPreparedQueries {
			method = "q.query"
		} else {
			method = db + ".QueryContext"
		}
	default:
		if g.tctx.EmitPreparedQueries {
			method = "q.exec"
		} else {
			method = db + ".ExecContext"
		}
	}

	params := q.Arg.Params()
	if params != "" {
		params = ", " + params
	}

	if g.tctx.EmitPreparedQueries {
		return fmt.Sprintf("%s(ctx, q.%s, %s%s)", method, q.FieldName, q.ConstantName, params)
	}
	return fmt.Sprintf("%s(ctx, %s%s)", method, q.ConstantName, params)
}

func (g *CodeGenerator) writeQuerySliceExec(body *strings.Builder, q Query, retval, db string, isPGX bool) {
	body.WriteString("\tquery := " + q.ConstantName + "\n")
	body.WriteString("\tvar queryParams []interface{}\n")

	if q.Arg.Struct != nil {
		for _, fld := range q.Arg.Struct.Fields {
			varName := q.Arg.VariableForField(fld)
			if fld.HasSqlcSlice() {
				fmt.Fprintf(body, "\tif len(%s) > 0 {\n", varName)
				fmt.Fprintf(body, "\t\tfor _, v := range %s {\n", varName)
				body.WriteString("\t\t\tqueryParams = append(queryParams, v)\n")
				body.WriteString("\t\t}\n")
				fmt.Fprintf(body, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , strings.Repeat(\",?\", len(%s))[1:], 1)\n", fld.Column.Name, varName)
				body.WriteString("\t} else {\n")
				fmt.Fprintf(body, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , \"NULL\", 1)\n", fld.Column.Name)
				body.WriteString("\t}\n")
			} else {
				fmt.Fprintf(body, "\tqueryParams = append(queryParams, %s)\n", varName)
			}
		}
	} else {
		argName := q.Arg.Name
		colName := q.Arg.Column.Name
		fmt.Fprintf(body, "\tif len(%s) > 0 {\n", argName)
		fmt.Fprintf(body, "\t\tfor _, v := range %s {\n", argName)
		body.WriteString("\t\t\tqueryParams = append(queryParams, v)\n")
		body.WriteString("\t\t}\n")
		fmt.Fprintf(body, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , strings.Repeat(\",?\", len(%s))[1:], 1)\n", colName, argName)
		body.WriteString("\t} else {\n")
		fmt.Fprintf(body, "\t\tquery = strings.Replace(query, \"/*SLICE:%s*/?\" , \"NULL\", 1)\n", colName)
		body.WriteString("\t}\n")
	}

	var method string
	switch q.Cmd {
	case ":one":
		if g.tctx.EmitPreparedQueries {
			method = "q.queryRow"
		} else {
			method = db + ".QueryRowContext"
		}
	case ":many":
		if g.tctx.EmitPreparedQueries {
			method = "q.query"
		} else {
			method = db + ".QueryContext"
		}
	default:
		if g.tctx.EmitPreparedQueries {
			method = "q.exec"
		} else {
			method = db + ".ExecContext"
		}
	}

	if g.tctx.EmitPreparedQueries {
		fmt.Fprintf(body, "\t%s %s(ctx, nil, query, queryParams...)\n", retval, method)
	} else {
		fmt.Fprintf(body, "\t%s %s(ctx, query, queryParams...)\n", retval, method)
	}
}

func (g *CodeGenerator) addQueryCodePGX(f *poet.File, sourceName string) {
	for _, q := range g.tctx.GoQueries {
		if q.SourceName != sourceName {
			continue
		}
		if strings.HasPrefix(q.Cmd, ":batch") {
			// Batch queries are fully handled in batch.go
			continue
		}
		if q.Cmd == metadata.CmdCopyFrom {
			// For copyfrom, only emit the struct definition (implementation is in copyfrom.go)
			if q.Arg.EmitStruct() {
				var fields []poet.Field
				for _, fld := range q.Arg.Struct.Fields {
					fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
				}
				f.Decls = append(f.Decls, poet.TypeDef{
					Name: q.Arg.Type(),
					Type: poet.Struct{Fields: fields},
				})
			}
			continue
		}
		g.addQueryPGX(f, q)
	}
}

func (g *CodeGenerator) addQueryPGX(f *poet.File, q Query) {
	// SQL constant
	f.Decls = append(f.Decls, poet.Const{
		Name:  q.ConstantName,
		Value: fmt.Sprintf("`-- name: %s %s\n%s\n`", q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL)),
	})

	// Arg struct if needed
	if q.Arg.EmitStruct() {
		var fields []poet.Field
		for _, fld := range q.Arg.Struct.Fields {
			fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.Arg.Type(),
			Type: poet.Struct{Fields: fields},
		})
	}

	// Ret struct if needed
	if q.Ret.EmitStruct() {
		var fields []poet.Field
		for _, fld := range q.Ret.Struct.Fields {
			fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
		}
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.Ret.Type(),
			Type: poet.Struct{Fields: fields},
		})
	}

	// Method
	switch q.Cmd {
	case ":one":
		g.addQueryOnePGX(f, q)
	case ":many":
		g.addQueryManyPGX(f, q)
	case ":exec":
		g.addQueryExecPGX(f, q)
	case ":execrows":
		g.addQueryExecRowsPGX(f, q)
	case ":execresult":
		g.addQueryExecResultPGX(f, q)
	}
}

func (g *CodeGenerator) buildQueryParamsPGX(q Query) []poet.Param {
	var params []poet.Param
	params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
	if g.tctx.EmitMethodsWithDBArgument {
		params = append(params, poet.Param{Name: "db", Type: "DBTX"})
	}
	if q.Arg.Pair() != "" {
		params = append(params, poet.Param{Name: "", Type: q.Arg.Pair()})
	}
	return params
}

func (g *CodeGenerator) addQueryOnePGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}
	fmt.Fprintf(&body, "\trow := %s.QueryRow(ctx, %s%s)\n", db, q.ConstantName, qParams)

	if q.Arg.Pair() != q.Ret.Pair() || q.Arg.DefineType() != q.Ret.DefineType() {
		fmt.Fprintf(&body, "\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	}

	fmt.Fprintf(&body, "\terr := row.Scan(%s)\n", q.Ret.Scan())

	if g.tctx.WrapErrors {
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
	}

	fmt.Fprintf(&body, "\treturn %s, err\n", q.Ret.ReturnName())

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: q.Ret.DefineType()}, {Type: "error"}},
		Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryManyPGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}
	fmt.Fprintf(&body, "\trows, err := %s.Query(ctx, %s%s)\n", db, q.ConstantName, qParams)

	body.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn nil, err\n")
	}
	body.WriteString("\t}\n")
	body.WriteString("\tdefer rows.Close()\n")

	if g.tctx.EmitEmptySlices {
		fmt.Fprintf(&body, "\titems := []%s{}\n", q.Ret.DefineType())
	} else {
		fmt.Fprintf(&body, "\tvar items []%s\n", q.Ret.DefineType())
	}

	body.WriteString("\tfor rows.Next() {\n")
	fmt.Fprintf(&body, "\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
	fmt.Fprintf(&body, "\t\tif err := rows.Scan(%s); err != nil {\n", q.Ret.Scan())
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\t\treturn nil, err\n")
	}
	body.WriteString("\t\t}\n")
	fmt.Fprintf(&body, "\t\titems = append(items, %s)\n", q.Ret.ReturnName())
	body.WriteString("\t}\n")

	body.WriteString("\tif err := rows.Err(); err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn nil, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn nil, err\n")
	}
	body.WriteString("\t}\n")

	body.WriteString("\treturn items, nil\n")

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "[]" + q.Ret.DefineType()}, {Type: "error"}},
		Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecPGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}
	fmt.Fprintf(&body, "\t_, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, qParams)

	if g.tctx.WrapErrors {
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\treturn fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
		body.WriteString("\treturn nil\n")
	} else {
		body.WriteString("\treturn err\n")
	}

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "error"}},
		Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecRowsPGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}
	fmt.Fprintf(&body, "\tresult, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, qParams)

	body.WriteString("\tif err != nil {\n")
	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\t\treturn 0, fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
	} else {
		body.WriteString("\t\treturn 0, err\n")
	}
	body.WriteString("\t}\n")
	body.WriteString("\treturn result.RowsAffected(), nil\n")

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
		Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addQueryExecResultPGX(f *poet.File, q Query) {
	db := "q.db"
	if g.tctx.EmitMethodsWithDBArgument {
		db = "db"
	}

	var body strings.Builder
	qParams := q.Arg.Params()
	if qParams != "" {
		qParams = ", " + qParams
	}

	if g.tctx.WrapErrors {
		fmt.Fprintf(&body, "\tresult, err := %s.Exec(ctx, %s%s)\n", db, q.ConstantName, qParams)
		body.WriteString("\tif err != nil {\n")
		fmt.Fprintf(&body, "\t\terr = fmt.Errorf(\"query %s: %%w\", err)\n", q.MethodName)
		body.WriteString("\t}\n")
		body.WriteString("\treturn result, err\n")
	} else {
		fmt.Fprintf(&body, "\treturn %s.Exec(ctx, %s%s)\n", db, q.ConstantName, qParams)
	}

	params := g.buildQueryParamsPGX(q)
	f.Decls = append(f.Decls, poet.Func{
		Comment: g.queryComments(q),
		Recv:    &poet.Param{Name: "q", Type: "*Queries"},
		Name:    q.MethodName,
		Params:  params,
		Results: []poet.Param{{Type: "pgconn.CommandTag"}, {Type: "error"}},
		Stmts:   []poet.Stmt{poet.RawStmt{Code: body.String()}},
	})
}

func (g *CodeGenerator) addCopyFromCodePGX(f *poet.File) {
	for _, q := range g.tctx.GoQueries {
		if q.Cmd != metadata.CmdCopyFrom {
			continue
		}

		iterName := "iteratorFor" + q.MethodName

		// Iterator struct
		f.Decls = append(f.Decls, poet.TypeDef{
			Comment: fmt.Sprintf("iteratorFor%s implements pgx.CopyFromSource.", q.MethodName),
			Name:    iterName,
			Type: poet.Struct{
				Fields: []poet.Field{
					{Name: "rows", Type: "[]" + q.Arg.DefineType()},
					{Name: "skippedFirstNextCall", Type: "bool"},
				},
			},
		})

		// Next method
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "r", Type: iterName, Pointer: true},
			Name:    "Next",
			Results: []poet.Param{{Type: "bool"}},
			Stmts: []poet.Stmt{
				poet.If{
					Cond: "len(r.rows) == 0",
					Body: []poet.Stmt{poet.Return{Values: []string{"false"}}},
				},
				poet.If{
					Cond: "!r.skippedFirstNextCall",
					Body: []poet.Stmt{
						poet.Assign{
							Left: []string{"r.skippedFirstNextCall"}, Op: "=",
							Right: []string{"true"},
						},
						poet.Return{Values: []string{"true"}},
					},
				},
				poet.Assign{Left: []string{"r.rows"}, Op: "=", Right: []string{"r.rows[1:]"}},
				poet.Return{Values: []string{"len(r.rows) > 0"}},
			},
		})

		// Values method
		var valuesBody strings.Builder
		valuesBody.WriteString("\treturn []interface{}{\n")
		if q.Arg.Struct != nil {
			for _, fld := range q.Arg.Struct.Fields {
				fmt.Fprintf(&valuesBody, "\t\tr.rows[0].%s,\n", fld.Name)
			}
		} else {
			valuesBody.WriteString("\t\tr.rows[0],\n")
		}
		valuesBody.WriteString("\t}, nil\n")

		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "r", Type: iterName},
			Name:    "Values",
			Results: []poet.Param{{Type: "[]interface{}"}, {Type: "error"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: valuesBody.String()}},
		})

		// Err method
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "r", Type: iterName},
			Name:    "Err",
			Results: []poet.Param{{Type: "error"}},
			Stmts:   []poet.Stmt{poet.Return{Values: []string{"nil"}}},
		})

		// Main method
		db := "q.db"
		var params []poet.Param
		params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			params = append(params, poet.Param{Name: "db", Type: "DBTX"})
		}
		params = append(params, poet.Param{Name: "", Type: q.Arg.SlicePair()})

		body := fmt.Sprintf("\treturn %s.CopyFrom(ctx, %s, %s, &%s{rows: %s})\n",
			db, q.TableIdentifierAsGoSlice(), q.Arg.ColumnNamesAsGoSlice(), iterName, q.Arg.Name)

		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: body}},
		})
	}
}

func (g *CodeGenerator) addCopyFromCodeMySQL(f *poet.File) {
	for _, q := range g.tctx.GoQueries {
		if q.Cmd != metadata.CmdCopyFrom {
			continue
		}

		// Reader handler sequence
		f.Decls = append(f.Decls, poet.Var{
			Name:  fmt.Sprintf("readerHandlerSequenceFor%s", q.MethodName),
			Type:  "uint32",
			Value: "1",
		})

		// Convert rows function
		var convertBody strings.Builder
		fmt.Fprintf(&convertBody, "\te := mysqltsv.NewEncoder(w, %d, nil)\n", len(q.Arg.CopyFromMySQLFields()))
		fmt.Fprintf(&convertBody, "\tfor _, row := range %s {\n", q.Arg.Name)

		for _, fld := range q.Arg.CopyFromMySQLFields() {
			accessor := "row"
			if q.Arg.Struct != nil {
				accessor = "row." + fld.Name
			}
			switch fld.Type {
			case "string":
				fmt.Fprintf(&convertBody, "\t\te.AppendString(%s)\n", accessor)
			case "[]byte", "json.RawMessage":
				fmt.Fprintf(&convertBody, "\t\te.AppendBytes(%s)\n", accessor)
			default:
				fmt.Fprintf(&convertBody, "\t\te.AppendValue(%s)\n", accessor)
			}
		}

		convertBody.WriteString("\t}\n")
		convertBody.WriteString("\tw.CloseWithError(e.Close())\n")

		f.Decls = append(f.Decls, poet.Func{
			Name:   fmt.Sprintf("convertRowsFor%s", q.MethodName),
			Params: []poet.Param{{Name: "w", Type: "*io.PipeWriter"}, {Name: "", Type: q.Arg.SlicePair()}},
			Stmts:  []poet.Stmt{poet.RawStmt{Code: convertBody.String()}},
		})

		// Main method
		db := "q.db"
		var params []poet.Param
		params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			params = append(params, poet.Param{Name: "db", Type: "DBTX"})
		}
		params = append(params, poet.Param{Name: "", Type: q.Arg.SlicePair()})

		var colNames []string
		for _, name := range q.Arg.ColumnNames() {
			colNames = append(colNames, name)
		}
		colList := strings.Join(colNames, ", ")

		var mainBody strings.Builder
		mainBody.WriteString("\tpr, pw := io.Pipe()\n")
		mainBody.WriteString("\tdefer pr.Close()\n")
		fmt.Fprintf(&mainBody, "\trh := fmt.Sprintf(\"%s_%%d\", atomic.AddUint32(&readerHandlerSequenceFor%s, 1))\n", q.MethodName, q.MethodName)
		mainBody.WriteString("\tmysql.RegisterReaderHandler(rh, func() io.Reader { return pr })\n")
		mainBody.WriteString("\tdefer mysql.DeregisterReaderHandler(rh)\n")
		fmt.Fprintf(&mainBody, "\tgo convertRowsFor%s(pw, %s)\n", q.MethodName, q.Arg.Name)
		mainBody.WriteString("\t// The string interpolation is necessary because LOAD DATA INFILE requires\n")
		mainBody.WriteString("\t// the file name to be given as a literal string.\n")
		fmt.Fprintf(&mainBody, "\tresult, err := %s.ExecContext(ctx, fmt.Sprintf(\"LOAD DATA LOCAL INFILE '%%s' INTO TABLE %s %%s (%s)\", \"Reader::\"+rh, mysqltsv.Escaping))\n",
			db, q.TableIdentifierForMySQL(), colList)
		mainBody.WriteString("\tif err != nil {\n")
		mainBody.WriteString("\t\treturn 0, err\n")
		mainBody.WriteString("\t}\n")
		mainBody.WriteString("\treturn result.RowsAffected()\n")

		comment := g.queryComments(q)
		comment += fmt.Sprintf("\n// %s uses MySQL's LOAD DATA LOCAL INFILE and is not atomic.", q.MethodName)
		comment += "\n//\n// Errors and duplicate keys are treated as warnings and insertion will"
		comment += "\n// continue, even without an error for some cases.  Use this in a transaction"
		comment += "\n// and use SHOW WARNINGS to check for any problems and roll back if you want to."
		comment += "\n//\n// Check the documentation for more information:"
		comment += "\n// https://dev.mysql.com/doc/refman/8.0/en/load-data.html#load-data-error-handling"

		f.Decls = append(f.Decls, poet.Func{
			Comment: comment,
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "int64"}, {Type: "error"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: mainBody.String()}},
		})
	}
}

func (g *CodeGenerator) addBatchCodePGX(f *poet.File) {
	// Error variable
	f.Decls = append(f.Decls, poet.VarBlock{
		Vars: []poet.Var{
			{Name: "ErrBatchAlreadyClosed", Value: `errors.New("batch already closed")`},
		},
	})

	for _, q := range g.tctx.GoQueries {
		if !strings.HasPrefix(q.Cmd, ":batch") {
			continue
		}

		// SQL constant
		f.Decls = append(f.Decls, poet.Const{
			Name:  q.ConstantName,
			Value: fmt.Sprintf("`-- name: %s %s\n%s\n`", q.MethodName, q.Cmd, sdk.EscapeBacktick(q.SQL)),
		})

		// BatchResults struct
		f.Decls = append(f.Decls, poet.TypeDef{
			Name: q.MethodName + "BatchResults",
			Type: poet.Struct{
				Fields: []poet.Field{
					{Name: "br", Type: "pgx.BatchResults"},
					{Name: "tot", Type: "int"},
					{Name: "closed", Type: "bool"},
				},
			},
		})

		// Arg struct if needed
		if q.Arg.Struct != nil {
			var fields []poet.Field
			for _, fld := range q.Arg.Struct.Fields {
				fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
			}
			f.Decls = append(f.Decls, poet.TypeDef{
				Name: q.Arg.Type(),
				Type: poet.Struct{Fields: fields},
			})
		}

		// Ret struct if needed
		if q.Ret.EmitStruct() {
			var fields []poet.Field
			for _, fld := range q.Ret.Struct.Fields {
				fields = append(fields, poet.Field{Name: fld.Name, Type: fld.Type, Tag: fld.Tag()})
			}
			f.Decls = append(f.Decls, poet.TypeDef{
				Name: q.Ret.Type(),
				Type: poet.Struct{Fields: fields},
			})
		}

		// Main batch method
		db := "q.db"
		var params []poet.Param
		params = append(params, poet.Param{Name: "ctx", Type: "context.Context"})
		if g.tctx.EmitMethodsWithDBArgument {
			db = "db"
			params = append(params, poet.Param{Name: "db", Type: "DBTX"})
		}
		params = append(params, poet.Param{Name: "", Type: q.Arg.SlicePair()})

		var mainBody strings.Builder
		mainBody.WriteString("\tbatch := &pgx.Batch{}\n")
		fmt.Fprintf(&mainBody, "\tfor _, a := range %s {\n", q.Arg.Name)
		mainBody.WriteString("\t\tvals := []interface{}{\n")
		if q.Arg.Struct != nil {
			for _, fld := range q.Arg.Struct.Fields {
				fmt.Fprintf(&mainBody, "\t\t\ta.%s,\n", fld.Name)
			}
		} else {
			mainBody.WriteString("\t\t\ta,\n")
		}
		mainBody.WriteString("\t\t}\n")
		fmt.Fprintf(&mainBody, "\t\tbatch.Queue(%s, vals...)\n", q.ConstantName)
		mainBody.WriteString("\t}\n")
		fmt.Fprintf(&mainBody, "\tbr := %s.SendBatch(ctx, batch)\n", db)
		fmt.Fprintf(&mainBody, "\treturn &%sBatchResults{br, len(%s), false}\n", q.MethodName, q.Arg.Name)

		f.Decls = append(f.Decls, poet.Func{
			Comment: g.queryComments(q),
			Recv:    &poet.Param{Name: "q", Type: "*Queries"},
			Name:    q.MethodName,
			Params:  params,
			Results: []poet.Param{{Type: "*" + q.MethodName + "BatchResults"}},
			Stmts:   []poet.Stmt{poet.RawStmt{Code: mainBody.String()}},
		})

		// Result method based on command type
		switch q.Cmd {
		case ":batchexec":
			f.Decls = append(f.Decls, poet.Func{
				Recv:   &poet.Param{Name: "b", Type: "*" + q.MethodName + "BatchResults"},
				Name:   "Exec",
				Params: []poet.Param{{Name: "f", Type: "func(int, error)"}},
				Stmts: []poet.Stmt{poet.RawStmt{Code: `	defer b.br.Close()
	for t := 0; t < b.tot; t++ {
		if b.closed {
			if f != nil {
				f(t, ErrBatchAlreadyClosed)
			}
			continue
		}
		_, err := b.br.Exec()
		if f != nil {
			f(t, err)
		}
	}
`}},
			})

		case ":batchmany":
			var batchManyBody strings.Builder
			batchManyBody.WriteString("\tdefer b.br.Close()\n")
			batchManyBody.WriteString("\tfor t := 0; t < b.tot; t++ {\n")
			if g.tctx.EmitEmptySlices {
				fmt.Fprintf(&batchManyBody, "\t\titems := []%s{}\n", q.Ret.DefineType())
			} else {
				fmt.Fprintf(&batchManyBody, "\t\tvar items []%s\n", q.Ret.DefineType())
			}
			batchManyBody.WriteString("\t\tif b.closed {\n")
			batchManyBody.WriteString("\t\t\tif f != nil {\n")
			batchManyBody.WriteString("\t\t\t\tf(t, items, ErrBatchAlreadyClosed)\n")
			batchManyBody.WriteString("\t\t\t}\n")
			batchManyBody.WriteString("\t\t\tcontinue\n")
			batchManyBody.WriteString("\t\t}\n")
			batchManyBody.WriteString("\t\terr := func() error {\n")
			batchManyBody.WriteString("\t\t\trows, err := b.br.Query()\n")
			batchManyBody.WriteString("\t\t\tif err != nil {\n")
			batchManyBody.WriteString("\t\t\t\treturn err\n")
			batchManyBody.WriteString("\t\t\t}\n")
			batchManyBody.WriteString("\t\t\tdefer rows.Close()\n")
			batchManyBody.WriteString("\t\t\tfor rows.Next() {\n")
			fmt.Fprintf(&batchManyBody, "\t\t\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
			fmt.Fprintf(&batchManyBody, "\t\t\t\tif err := rows.Scan(%s); err != nil {\n", q.Ret.Scan())
			batchManyBody.WriteString("\t\t\t\t\treturn err\n")
			batchManyBody.WriteString("\t\t\t\t}\n")
			fmt.Fprintf(&batchManyBody, "\t\t\t\titems = append(items, %s)\n", q.Ret.ReturnName())
			batchManyBody.WriteString("\t\t\t}\n")
			batchManyBody.WriteString("\t\t\treturn rows.Err()\n")
			batchManyBody.WriteString("\t\t}()\n")
			batchManyBody.WriteString("\t\tif f != nil {\n")
			batchManyBody.WriteString("\t\t\tf(t, items, err)\n")
			batchManyBody.WriteString("\t\t}\n")
			batchManyBody.WriteString("\t}\n")

			f.Decls = append(f.Decls, poet.Func{
				Recv:   &poet.Param{Name: "b", Type: "*" + q.MethodName + "BatchResults"},
				Name:   "Query",
				Params: []poet.Param{{Name: "f", Type: fmt.Sprintf("func(int, []%s, error)", q.Ret.DefineType())}},
				Stmts:  []poet.Stmt{poet.RawStmt{Code: batchManyBody.String()}},
			})

		case ":batchone":
			var batchOneBody strings.Builder
			batchOneBody.WriteString("\tdefer b.br.Close()\n")
			batchOneBody.WriteString("\tfor t := 0; t < b.tot; t++ {\n")
			fmt.Fprintf(&batchOneBody, "\t\tvar %s %s\n", q.Ret.Name, q.Ret.Type())
			batchOneBody.WriteString("\t\tif b.closed {\n")
			batchOneBody.WriteString("\t\t\tif f != nil {\n")
			if q.Ret.IsPointer() {
				batchOneBody.WriteString("\t\t\t\tf(t, nil, ErrBatchAlreadyClosed)\n")
			} else {
				fmt.Fprintf(&batchOneBody, "\t\t\t\tf(t, %s, ErrBatchAlreadyClosed)\n", q.Ret.Name)
			}
			batchOneBody.WriteString("\t\t\t}\n")
			batchOneBody.WriteString("\t\t\tcontinue\n")
			batchOneBody.WriteString("\t\t}\n")
			batchOneBody.WriteString("\t\trow := b.br.QueryRow()\n")
			fmt.Fprintf(&batchOneBody, "\t\terr := row.Scan(%s)\n", q.Ret.Scan())
			batchOneBody.WriteString("\t\tif f != nil {\n")
			fmt.Fprintf(&batchOneBody, "\t\t\tf(t, %s, err)\n", q.Ret.ReturnName())
			batchOneBody.WriteString("\t\t}\n")
			batchOneBody.WriteString("\t}\n")

			f.Decls = append(f.Decls, poet.Func{
				Recv:   &poet.Param{Name: "b", Type: "*" + q.MethodName + "BatchResults"},
				Name:   "QueryRow",
				Params: []poet.Param{{Name: "f", Type: fmt.Sprintf("func(int, %s, error)", q.Ret.DefineType())}},
				Stmts:  []poet.Stmt{poet.RawStmt{Code: batchOneBody.String()}},
			})
		}

		// Close method
		f.Decls = append(f.Decls, poet.Func{
			Recv:    &poet.Param{Name: "b", Type: q.MethodName + "BatchResults", Pointer: true},
			Name:    "Close",
			Results: []poet.Param{{Type: "error"}},
			Stmts: []poet.Stmt{
				poet.Assign{Left: []string{"b.closed"}, Op: "=", Right: []string{"true"}},
				poet.Return{Values: []string{"b.br.Close()"}},
			},
		})
	}
}
