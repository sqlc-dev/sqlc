// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package querytest

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const fullOuterJoinSubquery = `-- name: FullOuterJoinSubquery :many
SELECT table_a.id, table_a.name, si.id, a_id, si.name FROM a AS table_a
FULL OUTER JOIN (SELECT id, a_id, name FROM b WHERE b.name IS NOT NULL) si ON si.a_id = table_a.id
`

type FullOuterJoinSubqueryRow struct {
	ID     uuid.NullUUID
	Name   sql.NullString
	ID_2   uuid.NullUUID
	AID    uuid.NullUUID
	Name_2 sql.NullString
}

func (q *Queries) FullOuterJoinSubquery(ctx context.Context) ([]FullOuterJoinSubqueryRow, error) {
	rows, err := q.db.QueryContext(ctx, fullOuterJoinSubquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FullOuterJoinSubqueryRow
	for rows.Next() {
		var i FullOuterJoinSubqueryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ID_2,
			&i.AID,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const leftJoinSubquery = `-- name: LeftJoinSubquery :many
SELECT table_a.id, table_a.name, si.id, a_id, si.name FROM a AS table_a
LEFT JOIN (SELECT id, a_id, name FROM b WHERE b.name IS NOT NULL) si ON si.a_id = table_a.id
`

type LeftJoinSubqueryRow struct {
	ID     uuid.UUID
	Name   sql.NullString
	ID_2   uuid.NullUUID
	AID    uuid.NullUUID
	Name_2 sql.NullString
}

func (q *Queries) LeftJoinSubquery(ctx context.Context) ([]LeftJoinSubqueryRow, error) {
	rows, err := q.db.QueryContext(ctx, leftJoinSubquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeftJoinSubqueryRow
	for rows.Next() {
		var i LeftJoinSubqueryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ID_2,
			&i.AID,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const leftJoinSubqueryExplicitColumns = `-- name: LeftJoinSubqueryExplicitColumns :many
SELECT
    table_a.id,
    table_a.name,
    si.id,
    si.a_id,
    si.name
FROM a AS table_a
LEFT JOIN (SELECT id, a_id, name FROM b WHERE b.name IS NOT NULL) si ON si.a_id = table_a.id
`

type LeftJoinSubqueryExplicitColumnsRow struct {
	ID     uuid.UUID
	Name   sql.NullString
	ID_2   uuid.NullUUID
	AID    uuid.NullUUID
	Name_2 sql.NullString
}

func (q *Queries) LeftJoinSubqueryExplicitColumns(ctx context.Context) ([]LeftJoinSubqueryExplicitColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, leftJoinSubqueryExplicitColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeftJoinSubqueryExplicitColumnsRow
	for rows.Next() {
		var i LeftJoinSubqueryExplicitColumnsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ID_2,
			&i.AID,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const leftJoinSubqueryNoAlias = `-- name: LeftJoinSubqueryNoAlias :many
SELECT a.id, a.name, subquery.id, a_id, subquery.name FROM a
LEFT JOIN (SELECT id, a_id, name FROM b) subquery ON subquery.a_id = a.id
`

type LeftJoinSubqueryNoAliasRow struct {
	ID     uuid.UUID
	Name   sql.NullString
	ID_2   uuid.NullUUID
	AID    uuid.NullUUID
	Name_2 sql.NullString
}

func (q *Queries) LeftJoinSubqueryNoAlias(ctx context.Context) ([]LeftJoinSubqueryNoAliasRow, error) {
	rows, err := q.db.QueryContext(ctx, leftJoinSubqueryNoAlias)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LeftJoinSubqueryNoAliasRow
	for rows.Next() {
		var i LeftJoinSubqueryNoAliasRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ID_2,
			&i.AID,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rightJoinSubquery = `-- name: RightJoinSubquery :many
SELECT table_a.id, table_a.name, si.id, a_id, si.name FROM a AS table_a
RIGHT JOIN (SELECT id, a_id, name FROM b WHERE b.name IS NOT NULL) si ON si.a_id = table_a.id
`

type RightJoinSubqueryRow struct {
	ID     uuid.NullUUID
	Name   sql.NullString
	ID_2   uuid.UUID
	AID    uuid.UUID
	Name_2 sql.NullString
}

func (q *Queries) RightJoinSubquery(ctx context.Context) ([]RightJoinSubqueryRow, error) {
	rows, err := q.db.QueryContext(ctx, rightJoinSubquery)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RightJoinSubqueryRow
	for rows.Next() {
		var i RightJoinSubqueryRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.ID_2,
			&i.AID,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
