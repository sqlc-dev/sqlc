// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"net/netip"
	"time"
)

const getHttpStatusCodes = `-- name: GetHttpStatusCodes :many
SELECT
    status_code,
    COUNT(*) as count,
    AVG(response_time_ms) as avg_response_time
FROM web_logs
WHERE timestamp >= ?
GROUP BY status_code
ORDER BY count DESC;

`

type GetHttpStatusCodesRow struct {
	StatusCode      uint16
	Count           uint64
	AvgResponseTime float64
}

// Conditional expressions
func (q *Queries) GetHttpStatusCodes(ctx context.Context, timestamp time.Time) ([]GetHttpStatusCodesRow, error) {
	rows, err := q.db.QueryContext(ctx, getHttpStatusCodes, timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHttpStatusCodesRow
	for rows.Next() {
		var i GetHttpStatusCodesRow
		if err := rows.Scan(&i.StatusCode, &i.Count, &i.AvgResponseTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsForDateRange = `-- name: GetLogsForDateRange :many
SELECT
    id,
    ip_address,
    timestamp,
    url
FROM web_logs
WHERE toDate(timestamp) >= ? AND toDate(timestamp) <= ?
ORDER BY timestamp DESC;
`

type GetLogsForDateRangeParams struct {
	Timestamp   time.Time
	Timestamp_2 time.Time
}

type GetLogsForDateRangeRow struct {
	ID        uint32
	IpAddress netip.Addr
	Timestamp time.Time
	Url       string
}

func (q *Queries) GetLogsForDateRange(ctx context.Context, arg GetLogsForDateRangeParams) ([]GetLogsForDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getLogsForDateRange, arg.Timestamp, arg.Timestamp_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLogsForDateRangeRow
	for rows.Next() {
		var i GetLogsForDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.Timestamp,
			&i.Url,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsGroupedByHour = `-- name: GetLogsGroupedByHour :many
SELECT
    toStartOfHour(timestamp) as hour,
    COUNT(*) as request_count,
    AVG(response_time_ms) as avg_response_time
FROM web_logs
WHERE timestamp >= ?
GROUP BY hour
ORDER BY hour DESC;

`

type GetLogsGroupedByHourRow struct {
	Hour            interface{}
	RequestCount    uint64
	AvgResponseTime float64
}

// String functions
func (q *Queries) GetLogsGroupedByHour(ctx context.Context, timestamp time.Time) ([]GetLogsGroupedByHourRow, error) {
	rows, err := q.db.QueryContext(ctx, getLogsGroupedByHour, timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLogsGroupedByHourRow
	for rows.Next() {
		var i GetLogsGroupedByHourRow
		if err := rows.Scan(&i.Hour, &i.RequestCount, &i.AvgResponseTime); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsSummary = `-- name: GetLogsSummary :many
SELECT
    ip_address,
    COUNT(*) as request_count,
    CAST(AVG(response_time_ms) AS UInt32) as avg_time,
    CAST(MIN(timestamp) AS Date) as first_request,
    CAST(MAX(timestamp) AS Date) as last_request
FROM web_logs
WHERE timestamp >= ?
GROUP BY ip_address
ORDER BY request_count DESC;

`

type GetLogsSummaryRow struct {
	IpAddress    netip.Addr
	RequestCount uint64
	AvgTime      uint32
	FirstRequest time.Time
	LastRequest  time.Time
}

// Math functions
func (q *Queries) GetLogsSummary(ctx context.Context, timestamp time.Time) ([]GetLogsSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getLogsSummary, timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLogsSummaryRow
	for rows.Next() {
		var i GetLogsSummaryRow
		if err := rows.Scan(
			&i.IpAddress,
			&i.RequestCount,
			&i.AvgTime,
			&i.FirstRequest,
			&i.LastRequest,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsByTag = `-- name: GetMetricsByTag :many
SELECT
    name,
    value,
    tags,
    created_at
FROM metrics
WHERE tags['environment'] = ?
ORDER BY created_at DESC;
`

func (q *Queries) GetMetricsByTag(ctx context.Context, dollar_1 interface{}) ([]Metric, error) {
	rows, err := q.db.QueryContext(ctx, getMetricsByTag, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.Name,
			&i.Value,
			&i.Tags,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getResponseTimeStats = `-- name: GetResponseTimeStats :many
SELECT
    status_code,
    COUNT(*) as count,
    round(AVG(response_time_ms), 2) as avg_response_time,
    sqrt(varPop(response_time_ms)) as stddev
FROM web_logs
WHERE timestamp >= ?
GROUP BY status_code
ORDER BY avg_response_time DESC;

`

type GetResponseTimeStatsRow struct {
	StatusCode      uint16
	Count           uint64
	AvgResponseTime interface{}
	Stddev          interface{}
}

// Map type operations
func (q *Queries) GetResponseTimeStats(ctx context.Context, timestamp time.Time) ([]GetResponseTimeStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getResponseTimeStats, timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetResponseTimeStatsRow
	for rows.Next() {
		var i GetResponseTimeStatsRow
		if err := rows.Scan(
			&i.StatusCode,
			&i.Count,
			&i.AvgResponseTime,
			&i.Stddev,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlowRequests = `-- name: GetSlowRequests :many
SELECT
    id,
    url,
    response_time_ms,
    CASE
        WHEN response_time_ms > 1000 THEN 'very_slow'
        WHEN response_time_ms > 500 THEN 'slow'
        WHEN response_time_ms > 100 THEN 'medium'
        ELSE 'fast'
    END as performance
FROM web_logs
WHERE response_time_ms > ?
ORDER BY response_time_ms DESC;

`

type GetSlowRequestsRow struct {
	ID             uint32
	Url            string
	ResponseTimeMs uint32
	Performance    string
}

// Type casting
func (q *Queries) GetSlowRequests(ctx context.Context, responseTimeMs uint32) ([]GetSlowRequestsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSlowRequests, responseTimeMs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSlowRequestsRow
	for rows.Next() {
		var i GetSlowRequestsRow
		if err := rows.Scan(
			&i.ID,
			&i.Url,
			&i.ResponseTimeMs,
			&i.Performance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchLogsByUrl = `-- name: SearchLogsByUrl :many
SELECT
    id,
    ip_address,
    url,
    response_time_ms
FROM web_logs
WHERE url LIKE ?
ORDER BY timestamp DESC
LIMIT ?;
`

type SearchLogsByUrlParams struct {
	Url   string
	Limit int64
}

type SearchLogsByUrlRow struct {
	ID             uint32
	IpAddress      netip.Addr
	Url            string
	ResponseTimeMs uint32
}

func (q *Queries) SearchLogsByUrl(ctx context.Context, arg SearchLogsByUrlParams) ([]SearchLogsByUrlRow, error) {
	rows, err := q.db.QueryContext(ctx, searchLogsByUrl, arg.Url, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchLogsByUrlRow
	for rows.Next() {
		var i SearchLogsByUrlRow
		if err := rows.Scan(
			&i.ID,
			&i.IpAddress,
			&i.Url,
			&i.ResponseTimeMs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
