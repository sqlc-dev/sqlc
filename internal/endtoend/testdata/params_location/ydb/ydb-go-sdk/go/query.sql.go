// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package querytest

import (
	"context"

	"github.com/ydb-platform/ydb-go-sdk/v3"
	"github.com/ydb-platform/ydb-go-sdk/v3/pkg/xerrors"
	"github.com/ydb-platform/ydb-go-sdk/v3/query"
	"github.com/ydb-platform/ydb-go-sdk/v3/table/types"
)

const getUserByID = `-- name: GetUserByID :one
SELECT first_name, id, last_name FROM users WHERE id = $target_id
`

type GetUserByIDRow struct {
	FirstName *string
	ID        int64
	LastName  *string
}

func (q *Queries) GetUserByID(ctx context.Context, targetID int64, opts ...query.ExecuteOption) (GetUserByIDRow, error) {
	parameters := ydb.ParamsBuilder()
	parameters = parameters.Param("$target_id").Int64(targetID)
	row, err := q.db.QueryRow(ctx, getUserByID,
		append(opts, query.WithParameters(parameters.Build()))...,
	)
	var i GetUserByIDRow
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	err = row.Scan(&i.FirstName, &i.ID, &i.LastName)
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	return i, nil
}

const insertNewUser = `-- name: InsertNewUser :exec
INSERT INTO users (first_name, last_name) VALUES ($first_name, $last_name)
`

type InsertNewUserParams struct {
	FirstName *string
	LastName  *string
}

func (q *Queries) InsertNewUser(ctx context.Context, arg InsertNewUserParams, opts ...query.ExecuteOption) error {
	parameters := ydb.ParamsBuilder()
	parameters = parameters.Param("$first_name").BeginOptional().Text(arg.FirstName).EndOptional()
	parameters = parameters.Param("$last_name").BeginOptional().Text(arg.LastName).EndOptional()
	err := q.db.Exec(ctx, insertNewUser,
		append(opts, query.WithParameters(parameters.Build()))...,
	)
	if err != nil {
		return xerrors.WithStackTrace(err)
	}
	return nil
}

const limitSQLCArg = `-- name: LimitSQLCArg :many
select first_name, id FROM users LIMIT $limit
`

type LimitSQLCArgRow struct {
	FirstName *string
	ID        int64
}

func (q *Queries) LimitSQLCArg(ctx context.Context, limit uint64, opts ...query.ExecuteOption) ([]LimitSQLCArgRow, error) {
	parameters := ydb.ParamsBuilder()
	parameters = parameters.Param("$limit").Uint64(limit)
	result, err := q.db.QueryResultSet(ctx, limitSQLCArg,
		append(opts, query.WithParameters(parameters.Build()))...,
	)
	if err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	var items []LimitSQLCArgRow
	for row, err := range result.Rows(ctx) {
		if err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		var i LimitSQLCArgRow
		if err := row.Scan(&i.FirstName, &i.ID); err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		items = append(items, i)
	}
	if err := result.Close(ctx); err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	return items, nil
}

const listUserOrders = `-- name: ListUserOrders :many
SELECT
	users.id,
	users.first_name,
	orders.price
FROM
	orders
LEFT JOIN users ON orders.user_id = users.id
WHERE orders.price > $min_price
`

type ListUserOrdersRow struct {
	ID        *int64
	FirstName *string
	Price     *types.Decimal
}

func (q *Queries) ListUserOrders(ctx context.Context, minPrice *types.Decimal, opts ...query.ExecuteOption) ([]ListUserOrdersRow, error) {
	parameters := ydb.ParamsBuilder()
	parameters = parameters.Param("$min_price").BeginOptional().Decimal(&minPrice.Bytes, minPrice.Precision, minPrice.Scale).EndOptional()
	result, err := q.db.QueryResultSet(ctx, listUserOrders,
		append(opts, query.WithParameters(parameters.Build()))...,
	)
	if err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	var items []ListUserOrdersRow
	for row, err := range result.Rows(ctx) {
		if err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		var i ListUserOrdersRow
		if err := row.Scan(&i.ID, &i.FirstName, &i.Price); err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		items = append(items, i)
	}
	if err := result.Close(ctx); err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	return items, nil
}

const listUserParenExpr = `-- name: ListUserParenExpr :many
SELECT id, first_name, last_name, age, job_status FROM users WHERE (job_status = 'APPLIED' OR job_status = 'PENDING')
AND id > $id
ORDER BY id
LIMIT $limit
`

type ListUserParenExprParams struct {
	ID    int64
	Limit uint64
}

func (q *Queries) ListUserParenExpr(ctx context.Context, arg ListUserParenExprParams, opts ...query.ExecuteOption) ([]User, error) {
	parameters := ydb.ParamsBuilder()
	parameters = parameters.Param("$id").Int64(arg.ID)
	parameters = parameters.Param("$limit").Uint64(arg.Limit)
	result, err := q.db.QueryResultSet(ctx, listUserParenExpr,
		append(opts, query.WithParameters(parameters.Build()))...,
	)
	if err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	var items []User
	for row, err := range result.Rows(ctx) {
		if err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		var i User
		if err := row.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Age,
			&i.JobStatus,
		); err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		items = append(items, i)
	}
	if err := result.Close(ctx); err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	return items, nil
}

const listUsersByFamily = `-- name: ListUsersByFamily :many
SELECT first_name, last_name FROM users WHERE age < $max_age AND last_name = $in_family
`

type ListUsersByFamilyParams struct {
	MaxAge   *int64
	InFamily *string
}

type ListUsersByFamilyRow struct {
	FirstName *string
	LastName  *string
}

func (q *Queries) ListUsersByFamily(ctx context.Context, arg ListUsersByFamilyParams, opts ...query.ExecuteOption) ([]ListUsersByFamilyRow, error) {
	parameters := ydb.ParamsBuilder()
	parameters = parameters.Param("$max_age").BeginOptional().Int64(arg.MaxAge).EndOptional()
	parameters = parameters.Param("$in_family").BeginOptional().Text(arg.InFamily).EndOptional()
	result, err := q.db.QueryResultSet(ctx, listUsersByFamily,
		append(opts, query.WithParameters(parameters.Build()))...,
	)
	if err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	var items []ListUsersByFamilyRow
	for row, err := range result.Rows(ctx) {
		if err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		var i ListUsersByFamilyRow
		if err := row.Scan(&i.FirstName, &i.LastName); err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		items = append(items, i)
	}
	if err := result.Close(ctx); err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	return items, nil
}

const listUsersByID = `-- name: ListUsersByID :many
SELECT first_name, id, last_name FROM users WHERE id < $id
`

type ListUsersByIDRow struct {
	FirstName *string
	ID        int64
	LastName  *string
}

func (q *Queries) ListUsersByID(ctx context.Context, id int64, opts ...query.ExecuteOption) ([]ListUsersByIDRow, error) {
	parameters := ydb.ParamsBuilder()
	parameters = parameters.Param("$id").Int64(id)
	result, err := q.db.QueryResultSet(ctx, listUsersByID,
		append(opts, query.WithParameters(parameters.Build()))...,
	)
	if err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	var items []ListUsersByIDRow
	for row, err := range result.Rows(ctx) {
		if err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		var i ListUsersByIDRow
		if err := row.Scan(&i.FirstName, &i.ID, &i.LastName); err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		items = append(items, i)
	}
	if err := result.Close(ctx); err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	return items, nil
}

const listUsersWithLimit = `-- name: ListUsersWithLimit :many
SELECT first_name, last_name FROM users LIMIT $limit
`

type ListUsersWithLimitRow struct {
	FirstName *string
	LastName  *string
}

func (q *Queries) ListUsersWithLimit(ctx context.Context, limit uint64, opts ...query.ExecuteOption) ([]ListUsersWithLimitRow, error) {
	parameters := ydb.ParamsBuilder()
	parameters = parameters.Param("$limit").Uint64(limit)
	result, err := q.db.QueryResultSet(ctx, listUsersWithLimit,
		append(opts, query.WithParameters(parameters.Build()))...,
	)
	if err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	var items []ListUsersWithLimitRow
	for row, err := range result.Rows(ctx) {
		if err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		var i ListUsersWithLimitRow
		if err := row.Scan(&i.FirstName, &i.LastName); err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		items = append(items, i)
	}
	if err := result.Close(ctx); err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	return items, nil
}
