// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package querytest

import (
	"context"
)

const coalesceNumeric = `-- name: CoalesceNumeric :many
SELECT COALESCE(baz, 0) AS login
FROM foo
`

func (q *Queries) CoalesceNumeric(ctx context.Context) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, coalesceNumeric)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var login int64
		if err := rows.Scan(&login); err != nil {
			return nil, err
		}
		items = append(items, login)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const coalesceNumericColumns = `-- name: CoalesceNumericColumns :many
SELECT baz, qux, COALESCE(baz, qux)
FROM foo
`

type CoalesceNumericColumnsRow struct {
	Baz   *int64
	Qux   int64
	Baz_2 int64
}

func (q *Queries) CoalesceNumericColumns(ctx context.Context) ([]CoalesceNumericColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, coalesceNumericColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoalesceNumericColumnsRow
	for rows.Next() {
		var i CoalesceNumericColumnsRow
		if err := rows.Scan(&i.Baz, &i.Qux, &i.Baz_2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const coalesceNumericNull = `-- name: CoalesceNumericNull :many
SELECT baz, COALESCE(baz)
FROM foo
`

type CoalesceNumericNullRow struct {
	Baz   *int64
	Baz_2 *int64
}

func (q *Queries) CoalesceNumericNull(ctx context.Context) ([]CoalesceNumericNullRow, error) {
	rows, err := q.db.QueryContext(ctx, coalesceNumericNull)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoalesceNumericNullRow
	for rows.Next() {
		var i CoalesceNumericNullRow
		if err := rows.Scan(&i.Baz, &i.Baz_2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const coalesceString = `-- name: CoalesceString :many
SELECT COALESCE(bar, '') AS login
FROM foo
`

func (q *Queries) CoalesceString(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, coalesceString)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var login string
		if err := rows.Scan(&login); err != nil {
			return nil, err
		}
		items = append(items, login)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const coalesceStringColumns = `-- name: CoalesceStringColumns :many
SELECT bar, bat, COALESCE(bar, bat)
FROM foo
`

type CoalesceStringColumnsRow struct {
	Bar   *string
	Bat   string
	Bar_2 string
}

func (q *Queries) CoalesceStringColumns(ctx context.Context) ([]CoalesceStringColumnsRow, error) {
	rows, err := q.db.QueryContext(ctx, coalesceStringColumns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoalesceStringColumnsRow
	for rows.Next() {
		var i CoalesceStringColumnsRow
		if err := rows.Scan(&i.Bar, &i.Bat, &i.Bar_2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const coalesceStringNull = `-- name: CoalesceStringNull :many
SELECT bar, COALESCE(bar)
FROM foo
`

type CoalesceStringNullRow struct {
	Bar   *string
	Bar_2 *string
}

func (q *Queries) CoalesceStringNull(ctx context.Context) ([]CoalesceStringNullRow, error) {
	rows, err := q.db.QueryContext(ctx, coalesceStringNull)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoalesceStringNullRow
	for rows.Next() {
		var i CoalesceStringNullRow
		if err := rows.Scan(&i.Bar, &i.Bar_2); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
