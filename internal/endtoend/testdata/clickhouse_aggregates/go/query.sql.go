// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const getCategoryStats = `-- name: GetCategoryStats :many
SELECT
    category,
    COUNT(*) as all_sales,
    countIf(amount > 100) as high_value_sales,
    sumIf(amount, quantity > 5) as revenue_bulk_orders,
    avgIf(amount, amount > 50) as avg_high_value
FROM sales
WHERE created_at >= ?
GROUP BY category;

`

type GetCategoryStatsRow struct {
	Category          string
	AllSales          uint64
	HighValueSales    uint64
	RevenueBulkOrders float64
	AvgHighValue      float64
}

// HAVING clause
func (q *Queries) GetCategoryStats(ctx context.Context, createdAt time.Time) ([]GetCategoryStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCategoryStats, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCategoryStatsRow
	for rows.Next() {
		var i GetCategoryStatsRow
		if err := rows.Scan(
			&i.Category,
			&i.AllSales,
			&i.HighValueSales,
			&i.RevenueBulkOrders,
			&i.AvgHighValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductCategoryStats = `-- name: GetProductCategoryStats :many
SELECT
    product_id,
    category,
    COUNT(*) as count,
    SUM(amount) as total
FROM sales
GROUP BY product_id, category
ORDER BY product_id, total DESC;
`

type GetProductCategoryStatsRow struct {
	ProductID uint32
	Category  string
	Count     uint64
	Total     float64
}

func (q *Queries) GetProductCategoryStats(ctx context.Context) ([]GetProductCategoryStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProductCategoryStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProductCategoryStatsRow
	for rows.Next() {
		var i GetProductCategoryStatsRow
		if err := rows.Scan(
			&i.ProductID,
			&i.Category,
			&i.Count,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSalesStatistics = `-- name: GetSalesStatistics :many
SELECT
    category,
    COUNT(*) as total_sales,
    SUM(amount) as total_revenue,
    AVG(amount) as avg_amount,
    MIN(amount) as min_amount,
    MAX(amount) as max_amount,
    SUM(quantity) as total_quantity
FROM sales
GROUP BY category
ORDER BY total_revenue DESC;

`

type GetSalesStatisticsRow struct {
	Category      string
	TotalSales    uint64
	TotalRevenue  float64
	AvgAmount     float64
	MinAmount     float64
	MaxAmount     float64
	TotalQuantity uint32
}

// Conditional aggregates
func (q *Queries) GetSalesStatistics(ctx context.Context) ([]GetSalesStatisticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getSalesStatistics)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSalesStatisticsRow
	for rows.Next() {
		var i GetSalesStatisticsRow
		if err := rows.Scan(
			&i.Category,
			&i.TotalSales,
			&i.TotalRevenue,
			&i.AvgAmount,
			&i.MinAmount,
			&i.MaxAmount,
			&i.TotalQuantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCategories = `-- name: GetTopCategories :many
SELECT
    category,
    COUNT(*) as sale_count,
    SUM(amount) as total_amount
FROM sales
GROUP BY category
ORDER BY total_amount DESC;

`

type GetTopCategoriesRow struct {
	Category    string
	SaleCount   uint64
	TotalAmount float64
}

// Multiple GROUP BY columns
func (q *Queries) GetTopCategories(ctx context.Context) ([]GetTopCategoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopCategoriesRow
	for rows.Next() {
		var i GetTopCategoriesRow
		if err := rows.Scan(&i.Category, &i.SaleCount, &i.TotalAmount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
