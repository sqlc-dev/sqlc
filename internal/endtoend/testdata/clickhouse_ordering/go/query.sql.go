// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const listOrdersAscending = `-- name: ListOrdersAscending :many
SELECT id, total FROM orders ORDER BY total ASC;
`

type ListOrdersAscendingRow struct {
	ID    uint32
	Total float32
}

func (q *Queries) ListOrdersAscending(ctx context.Context) ([]ListOrdersAscendingRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersAscending)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersAscendingRow
	for rows.Next() {
		var i ListOrdersAscendingRow
		if err := rows.Scan(&i.ID, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByCustomerAndDate = `-- name: ListOrdersByCustomerAndDate :many
SELECT id, customer_name, created_at FROM orders ORDER BY customer_name, created_at DESC;
`

type ListOrdersByCustomerAndDateRow struct {
	ID           uint32
	CustomerName string
	CreatedAt    time.Time
}

func (q *Queries) ListOrdersByCustomerAndDate(ctx context.Context) ([]ListOrdersByCustomerAndDateRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByCustomerAndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersByCustomerAndDateRow
	for rows.Next() {
		var i ListOrdersByCustomerAndDateRow
		if err := rows.Scan(&i.ID, &i.CustomerName, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrdersByTotal = `-- name: ListOrdersByTotal :many
SELECT id, customer_name, total FROM orders ORDER BY total DESC;
`

type ListOrdersByTotalRow struct {
	ID           uint32
	CustomerName string
	Total        float32
}

func (q *Queries) ListOrdersByTotal(ctx context.Context) ([]ListOrdersByTotalRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByTotal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersByTotalRow
	for rows.Next() {
		var i ListOrdersByTotalRow
		if err := rows.Scan(&i.ID, &i.CustomerName, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
