// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package querytest

import (
	"context"

	"github.com/ydb-platform/ydb-go-sdk/v3/pkg/xerrors"
	"github.com/ydb-platform/ydb-go-sdk/v3/query"
)

const duplicate = `-- name: Duplicate :one
SELECT users.id, users.name, users.age, users.id, users.name, users.age FROM users
`

type DuplicateRow struct {
	User   User
	User_2 User
}

func (q *Queries) Duplicate(ctx context.Context, opts ...query.ExecuteOption) (DuplicateRow, error) {
	row, err := q.db.QueryRow(ctx, duplicate, opts...)
	var i DuplicateRow
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	err = row.Scan(
		&i.User.ID,
		&i.User.Name,
		&i.User.Age,
		&i.User_2.ID,
		&i.User_2.Name,
		&i.User_2.Age,
	)
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	return i, nil
}

const join = `-- name: Join :one
SELECT users.id, users.name, users.age, posts.id, posts.user_id, posts.likes FROM posts
INNER JOIN users ON posts.user_id = users.id
`

type JoinRow struct {
	User User
	Post Post
}

func (q *Queries) Join(ctx context.Context, opts ...query.ExecuteOption) (JoinRow, error) {
	row, err := q.db.QueryRow(ctx, join, opts...)
	var i JoinRow
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	err = row.Scan(
		&i.User.ID,
		&i.User.Name,
		&i.User.Age,
		&i.Post.ID,
		&i.Post.UserID,
		&i.Post.Likes,
	)
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	return i, nil
}

const only = `-- name: Only :one
SELECT users.id, users.name, users.age FROM users
`

type OnlyRow struct {
	User User
}

func (q *Queries) Only(ctx context.Context, opts ...query.ExecuteOption) (OnlyRow, error) {
	row, err := q.db.QueryRow(ctx, only, opts...)
	var i OnlyRow
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	err = row.Scan(&i.User.ID, &i.User.Name, &i.User.Age)
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	return i, nil
}

const withAlias = `-- name: WithAlias :one
SELECT u.id, u.name, u.age FROM users u
`

type WithAliasRow struct {
	User User
}

func (q *Queries) WithAlias(ctx context.Context, opts ...query.ExecuteOption) (WithAliasRow, error) {
	row, err := q.db.QueryRow(ctx, withAlias, opts...)
	var i WithAliasRow
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	err = row.Scan(&i.User.ID, &i.User.Name, &i.User.Age)
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	return i, nil
}

const withAsterisk = `-- name: WithAsterisk :one
SELECT users.id, users.name, users.age, id, name, age FROM users
`

type WithAsteriskRow struct {
	User User
	ID   int32
	Name string
	Age  *int32
}

func (q *Queries) WithAsterisk(ctx context.Context, opts ...query.ExecuteOption) (WithAsteriskRow, error) {
	row, err := q.db.QueryRow(ctx, withAsterisk, opts...)
	var i WithAsteriskRow
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	err = row.Scan(
		&i.User.ID,
		&i.User.Name,
		&i.User.Age,
		&i.ID,
		&i.Name,
		&i.Age,
	)
	if err != nil {
		return i, xerrors.WithStackTrace(err)
	}
	return i, nil
}

const withSubquery = `-- name: WithSubquery :many
SELECT users.id, users.name, users.age, Count(*) AS total_count FROM users
`

type WithSubqueryRow struct {
	User       User
	TotalCount uint64
}

func (q *Queries) WithSubquery(ctx context.Context, opts ...query.ExecuteOption) ([]WithSubqueryRow, error) {
	result, err := q.db.QueryResultSet(ctx, withSubquery, opts...)
	if err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	var items []WithSubqueryRow
	for row, err := range result.Rows(ctx) {
		if err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		var i WithSubqueryRow
		if err := row.Scan(
			&i.User.ID,
			&i.User.Name,
			&i.User.Age,
			&i.TotalCount,
		); err != nil {
			return nil, xerrors.WithStackTrace(err)
		}
		items = append(items, i)
	}
	if err := result.Close(ctx); err != nil {
		return nil, xerrors.WithStackTrace(err)
	}
	return items, nil
}
