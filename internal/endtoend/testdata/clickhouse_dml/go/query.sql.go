// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const countUnreadNotifications = `-- name: CountUnreadNotifications :one
SELECT COUNT(*) as unread_count
FROM notifications
WHERE user_id = ? AND read_status = 0;
`

func (q *Queries) CountUnreadNotifications(ctx context.Context, userID uint32) (uint64, error) {
	row := q.db.QueryRowContext(ctx, countUnreadNotifications, userID)
	var unread_count uint64
	err := row.Scan(&unread_count)
	return unread_count, err
}

const getLogs = `-- name: GetLogs :many
SELECT id, level, message, timestamp, source
FROM logs
WHERE timestamp >= ?
ORDER BY timestamp DESC
LIMIT ?;
`

type GetLogsParams struct {
	Timestamp time.Time
	Limit     int64
}

func (q *Queries) GetLogs(ctx context.Context, arg GetLogsParams) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogs, arg.Timestamp, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Timestamp,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLogsByLevel = `-- name: GetLogsByLevel :many
SELECT id, level, message, timestamp, source
FROM logs
WHERE level = ?
ORDER BY timestamp DESC;
`

func (q *Queries) GetLogsByLevel(ctx context.Context, level string) ([]Log, error) {
	rows, err := q.db.QueryContext(ctx, getLogsByLevel, level)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Log
	for rows.Next() {
		var i Log
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Message,
			&i.Timestamp,
			&i.Source,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotificationSummary = `-- name: GetNotificationSummary :many
SELECT
    level,
    COUNT(*) as count
FROM logs
WHERE timestamp >= ?
GROUP BY level
ORDER BY count DESC;
`

type GetNotificationSummaryRow struct {
	Level string
	Count uint64
}

func (q *Queries) GetNotificationSummary(ctx context.Context, timestamp time.Time) ([]GetNotificationSummaryRow, error) {
	rows, err := q.db.QueryContext(ctx, getNotificationSummary, timestamp)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNotificationSummaryRow
	for rows.Next() {
		var i GetNotificationSummaryRow
		if err := rows.Scan(&i.Level, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNotifications = `-- name: GetNotifications :many
SELECT id, user_id, message, read_status, created_at
FROM notifications
WHERE user_id = ?
ORDER BY created_at DESC;
`

func (q *Queries) GetNotifications(ctx context.Context, userID uint32) ([]Notification, error) {
	rows, err := q.db.QueryContext(ctx, getNotifications, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Notification
	for rows.Next() {
		var i Notification
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Message,
			&i.ReadStatus,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertLog = `-- name: InsertLog :exec
INSERT INTO logs (id, level, message, timestamp, source)
VALUES (?, ?, ?, ?, ?);
`

type InsertLogParams struct {
	ID        uint32
	Level     string
	Message   string
	Timestamp time.Time
	Source    string
}

func (q *Queries) InsertLog(ctx context.Context, arg InsertLogParams) error {
	_, err := q.db.ExecContext(ctx, insertLog,
		arg.ID,
		arg.Level,
		arg.Message,
		arg.Timestamp,
		arg.Source,
	)
	return err
}

const insertMultipleLogs = `-- name: InsertMultipleLogs :exec
INSERT INTO logs (id, level, message, timestamp, source)
VALUES
    (?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?),
    (?, ?, ?, ?, ?);
`

type InsertMultipleLogsParams struct {
	ID          uint32
	Level       string
	Message     string
	Timestamp   time.Time
	Source      string
	ID_2        uint32
	Level_2     string
	Message_2   string
	Timestamp_2 time.Time
	Source_2    string
	ID_3        uint32
	Level_3     string
	Message_3   string
	Timestamp_3 time.Time
	Source_3    string
}

func (q *Queries) InsertMultipleLogs(ctx context.Context, arg InsertMultipleLogsParams) error {
	_, err := q.db.ExecContext(ctx, insertMultipleLogs,
		arg.ID,
		arg.Level,
		arg.Message,
		arg.Timestamp,
		arg.Source,
		arg.ID_2,
		arg.Level_2,
		arg.Message_2,
		arg.Timestamp_2,
		arg.Source_2,
		arg.ID_3,
		arg.Level_3,
		arg.Message_3,
		arg.Timestamp_3,
		arg.Source_3,
	)
	return err
}

const insertNotification = `-- name: InsertNotification :exec
INSERT INTO notifications (id, user_id, message, read_status, created_at)
VALUES (?, ?, ?, ?, ?);

`

type InsertNotificationParams struct {
	ID         uint32
	UserID     uint32
	Message    string
	ReadStatus uint8
	CreatedAt  time.Time
}

// Select for use in tests
func (q *Queries) InsertNotification(ctx context.Context, arg InsertNotificationParams) error {
	_, err := q.db.ExecContext(ctx, insertNotification,
		arg.ID,
		arg.UserID,
		arg.Message,
		arg.ReadStatus,
		arg.CreatedAt,
	)
	return err
}
