// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package querytest

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const callInsertData = `-- name: CallInsertData :one
CALL insert_data($1, $2, null, null, null, null, null, null, null, null, null, null, null)
`

type CallInsertDataParams struct {
	A int32
	B int32
}

type CallInsertDataRow struct {
	C pgtype.Int4
	I pgtype.Float8
	J pgtype.Numeric
	K pgtype.Float4
	D pgtype.Text
	H pgtype.Text
	E pgtype.Timestamp
	M pgtype.Interval
	F []byte
	G []byte
	L pgtype.Bool
}

func (q *Queries) CallInsertData(ctx context.Context, arg CallInsertDataParams) (CallInsertDataRow, error) {
	row := q.db.QueryRow(ctx, callInsertData, arg.A, arg.B)
	var i CallInsertDataRow
	err := row.Scan(
		&i.C,
		&i.I,
		&i.J,
		&i.K,
		&i.D,
		&i.H,
		&i.E,
		&i.M,
		&i.F,
		&i.G,
		&i.L,
	)
	return i, err
}

const callInsertDataNamed = `-- name: CallInsertDataNamed :one
CALL insert_data(
        b => $1,
        a => $2,
        c => null,
        i => null,
        j => null,
        k => null,
        d => null,
        h => null,
        e => null,
        m => null,
        f => null,
        g => null,
        l => null
     )
`

type CallInsertDataNamedParams struct {
	B int32
	A int32
}

type CallInsertDataNamedRow struct {
	C pgtype.Int4
	I pgtype.Float8
	J pgtype.Numeric
	K pgtype.Float4
	D pgtype.Text
	H pgtype.Text
	E pgtype.Timestamp
	M pgtype.Interval
	F []byte
	G []byte
	L pgtype.Bool
}

func (q *Queries) CallInsertDataNamed(ctx context.Context, arg CallInsertDataNamedParams) (CallInsertDataNamedRow, error) {
	row := q.db.QueryRow(ctx, callInsertDataNamed, arg.B, arg.A)
	var i CallInsertDataNamedRow
	err := row.Scan(
		&i.C,
		&i.I,
		&i.J,
		&i.K,
		&i.D,
		&i.H,
		&i.E,
		&i.M,
		&i.F,
		&i.G,
		&i.L,
	)
	return i, err
}

const callInsertDataNoArgs = `-- name: CallInsertDataNoArgs :one
CALL insert_data(1, 2, null, null, null, null, null, null, null, null, null, null, null)
`

type CallInsertDataNoArgsRow struct {
	C pgtype.Int4
	I pgtype.Float8
	J pgtype.Numeric
	K pgtype.Float4
	D pgtype.Text
	H pgtype.Text
	E pgtype.Timestamp
	M pgtype.Interval
	F []byte
	G []byte
	L pgtype.Bool
}

func (q *Queries) CallInsertDataNoArgs(ctx context.Context) (CallInsertDataNoArgsRow, error) {
	row := q.db.QueryRow(ctx, callInsertDataNoArgs)
	var i CallInsertDataNoArgsRow
	err := row.Scan(
		&i.C,
		&i.I,
		&i.J,
		&i.K,
		&i.D,
		&i.H,
		&i.E,
		&i.M,
		&i.F,
		&i.G,
		&i.L,
	)
	return i, err
}

const callInsertDataSqlcArgs = `-- name: CallInsertDataSqlcArgs :one
CALL insert_data($1, $2, null, null, null, null, null, null, null, null, null, null, null)
`

type CallInsertDataSqlcArgsParams struct {
	Foo int32
	Bar int32
}

type CallInsertDataSqlcArgsRow struct {
	C pgtype.Int4
	I pgtype.Float8
	J pgtype.Numeric
	K pgtype.Float4
	D pgtype.Text
	H pgtype.Text
	E pgtype.Timestamp
	M pgtype.Interval
	F []byte
	G []byte
	L pgtype.Bool
}

func (q *Queries) CallInsertDataSqlcArgs(ctx context.Context, arg CallInsertDataSqlcArgsParams) (CallInsertDataSqlcArgsRow, error) {
	row := q.db.QueryRow(ctx, callInsertDataSqlcArgs, arg.Foo, arg.Bar)
	var i CallInsertDataSqlcArgsRow
	err := row.Scan(
		&i.C,
		&i.I,
		&i.J,
		&i.K,
		&i.D,
		&i.H,
		&i.E,
		&i.M,
		&i.F,
		&i.G,
		&i.L,
	)
	return i, err
}
