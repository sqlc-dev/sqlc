// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const getCastToDate = `-- name: GetCastToDate :many
SELECT id, CAST(created_date AS Date) AS date FROM data;
`

type GetCastToDateRow struct {
	ID   uint32
	Date time.Time
}

func (q *Queries) GetCastToDate(ctx context.Context) ([]GetCastToDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getCastToDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCastToDateRow
	for rows.Next() {
		var i GetCastToDateRow
		if err := rows.Scan(&i.ID, &i.Date); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCastToFloat = `-- name: GetCastToFloat :many
SELECT id, CAST(amount AS Float32) AS amount FROM data;
`

type GetCastToFloatRow struct {
	ID     uint32
	Amount float32
}

func (q *Queries) GetCastToFloat(ctx context.Context) ([]GetCastToFloatRow, error) {
	rows, err := q.db.QueryContext(ctx, getCastToFloat)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCastToFloatRow
	for rows.Next() {
		var i GetCastToFloatRow
		if err := rows.Scan(&i.ID, &i.Amount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCastToInt = `-- name: GetCastToInt :many
SELECT id, CAST(quantity AS UInt32) AS quantity FROM data;
`

type GetCastToIntRow struct {
	ID       uint32
	Quantity uint32
}

func (q *Queries) GetCastToInt(ctx context.Context) ([]GetCastToIntRow, error) {
	rows, err := q.db.QueryContext(ctx, getCastToInt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCastToIntRow
	for rows.Next() {
		var i GetCastToIntRow
		if err := rows.Scan(&i.ID, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMultipleCasts = `-- name: GetMultipleCasts :many
SELECT id, CAST(amount AS Float32) AS amount_float, CAST(quantity AS UInt32) AS quantity_int FROM data;
`

type GetMultipleCastsRow struct {
	ID          uint32
	AmountFloat float32
	QuantityInt uint32
}

func (q *Queries) GetMultipleCasts(ctx context.Context) ([]GetMultipleCastsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMultipleCasts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMultipleCastsRow
	for rows.Next() {
		var i GetMultipleCastsRow
		if err := rows.Scan(&i.ID, &i.AmountFloat, &i.QuantityInt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
